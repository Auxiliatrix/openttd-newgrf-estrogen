grf {
    grfid: "AK01";
    name: string(STR_GRF_NAME);
    desc: string(STR_GRF_DESCRIPTION);
    version: 0;
    min_compatible_version: 0;
    param 0 {
        hormone {
            type: int;
            name: string(STR_PARAM_NAME_HORMONE);
            desc: string(STR_PARAM_DESC_HORMONE);
            min_value: 0;
            max_value: 2;
            def_value: 0;
            names: {
                0: string(STR_PARAM_VALUE_HORMONE_ESTROGEN);
                1: string(STR_PARAM_VALUE_HORMONE_TESTOSTERONE);
                2: string(STR_PARAM_VALUE_HORMONE_BOTH);
            };
        }
    }
    param 1 {
        industry_decay {
            type: bool;
            name: string(STR_PARAM_NAME_INDUSTRY_DECAY);
            desc: string(STR_PARAM_DESC_INDUSTRY_DECAY);
            def_value: 1;
        }
    }
    param 2 {
        industry_growth {
            type: bool;
            name: string(STR_PARAM_NAME_INDUSTRY_GROWTH);
            desc: string(STR_PARAM_DESC_INDUSTRY_GROWTH);
            def_value: 1;
        }
    }
    param 3 {
        industry_close {
            type: bool;
            name: string(STR_PARAM_NAME_INDUSTRY_CLOSE);
            desc: string(STR_PARAM_DESC_INDUSTRY_CLOSE);
            def_value: 1;
        }
    }
    param 4 {
        industry_starting_power {
            type: int;
            name: string(STR_PARAM_NAME_INDUSTRY_STARTING_POWER);
            desc: string(STR_PARAM_DESC_INDUSTRY_STARTING_POWER);
            min_value: 1;
            max_value: 6;
            def_value: 3;
            names: {
                1: string(STR_INDUSTRY_POWER_MINIMUM);
                2: string(STR_INDUSTRY_POWER_LOW);
                3: string(STR_INDUSTRY_POWER_DEFAULT);
                4: string(STR_INDUSTRY_POWER_HIGH);
                5: string(STR_INDUSTRY_POWER_VERY_HIGH);
                6: string(STR_INDUSTRY_POWER_MAXIMUM);
            };
        }
    }
}

// TODO: dont accept cargo if <16 total units of input
// TODO: randomization broken again

// Listen. Yes, this is all in one file. That's just how openttd NML works, for some reason.
// Yes, I could build a basic templating program to do actual compartmentalization,
// But I'm lazy and this mod is supposed to be a meme, so one giant .nml file it is.

// ----------------------------------------------------------------
// Conventions
// ----------------------------------------------------------------

// BOOST_CARGO_FIRST    :Cargos that boost production should be listed first in all indexes.

// ----------------------------------------------------------------
// Settings
// ----------------------------------------------------------------

cargotable {
    PASS, MAIL, GOOD, ENGS, FERT, SALT, PTSH, SAND, MNRL, CORN, SOYB, YAMS, VIAL, CHEM, VGOL, ALCH, DIOS, RWES, RWTS, ESTR, TEST
}

disable_item(FEAT_CARGOS, 1);
disable_item(FEAT_CARGOS, 3, 4);
disable_item(FEAT_CARGOS, 6, 11);
disable_item(FEAT_INDUSTRIES, 0, 36);

switch (FEAT_INDUSTRIES, SELF, availability_in_estrogen, hormone) {
    0: return CB_RESULT_IND_PROBABILITY_FROM_PROPERTY;
    1: return CB_RESULT_IND_NO_CONSTRUCTION;
    2: return CB_RESULT_IND_PROBABILITY_FROM_PROPERTY;
    return CB_RESULT_IND_NO_CONSTRUCTION;
}

switch (FEAT_INDUSTRIES, SELF, availability_in_testosterone, hormone) {
    0: return CB_RESULT_IND_NO_CONSTRUCTION;
    1: return CB_RESULT_IND_PROBABILITY_FROM_PROPERTY;
    2: return CB_RESULT_IND_PROBABILITY_FROM_PROPERTY;
    return CB_RESULT_IND_NO_CONSTRUCTION;
}

// ----------------------------------------------------------------
// Cargo Definitions
// ----------------------------------------------------------------

// --------------------------------
// Cargo Sprites
// --------------------------------

spriteset(sprite_engineering_supplies, "./gfx/engineering_supplies.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_fertilizer, "./gfx/fertilizer.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_salt, "./gfx/salt.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_potash, "./gfx/potash.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_sand, "./gfx/sand.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_minerals, "./gfx/minerals.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_corn, "./gfx/corn.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_soybeans, "./gfx/soybeans.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_yams, "./gfx/yams.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_vials, "./gfx/vials.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_vegetable_oil, "./gfx/vegetable_oil.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_chemicals, "./gfx/chemicals.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_alcohol, "./gfx/alcohol.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_diosgenin, "./gfx/diosgenin.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_raw_estrone, "./gfx/raw_estrone.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_raw_testosterone, "./gfx/raw_testosterone.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_estrogen, "./gfx/estrogen.png") {
    [0, 0, 8, 8, 0, 0]
}

spriteset(sprite_testosterone, "./gfx/testosterone.png") {
    [0, 0, 8, 8, 0, 0]
}

// --------------------------------
// Cargo Items
// --------------------------------

item (FEAT_CARGOS, item_passengers) {
    property {
        number: 0;
        type_name: TTD_STR_CARGO_PLURAL_PASSENGERS;
        unit_name: TTD_STR_CARGO_SINGULAR_PASSENGER;
        type_abbreviation: TTD_STR_ABBREV_PASSENGERS;
        cargo_label: "PASS";
        units_of_cargo: TTD_STR_PASSENGERS;
        items_of_cargo: TTD_STR_QUANTITY_PASSENGERS;
        cargo_classes: bitmask(CC_PASSENGERS);
        penalty_lowerbound: 0;
        single_penalty_length: 22;
        price_factor: 137;
        weight: 0.0625;
        is_freight: 0;
        capacity_multiplier: 4;
        sprite: NEW_CARGO_SPRITE;
        town_growth_effect: TOWNGROWTH_PASSENGERS;
        town_growth_multiplier: 1.0;
        sprite: 4297;
    }
}

item (FEAT_CARGOS, item_mail) {
    property {
        number: 2;
        type_name: TTD_STR_CARGO_PLURAL_MAIL;
        unit_name: TTD_STR_CARGO_SINGULAR_MAIL;
        type_abbreviation: TTD_STR_ABBREV_MAIL;
        cargo_label: "MAIL";
        units_of_cargo: TTD_STR_BAGS;
        items_of_cargo: TTD_STR_QUANTITY_MAIL;
        cargo_classes: bitmask(CC_MAIL);
        penalty_lowerbound: 6;
        single_penalty_length: 24;
        price_factor: 167;
        weight: 0.25;
        is_freight: 0;
        capacity_multiplier: 2;
        town_growth_effect: TOWNGROWTH_MAIL;
        town_growth_multiplier: 1.0;
        sprite: 4299;
    }
}

item (FEAT_CARGOS, item_goods) {
    property {
        number: 5;
        type_name: TTD_STR_CARGO_PLURAL_GOODS;
        unit_name: TTD_STR_CARGO_SINGULAR_GOODS;
        type_abbreviation: TTD_STR_ABBREV_GOODS;
        cargo_label: "GOOD";
        station_list_colour: 63;
        cargo_payment_list_colour: 63;
        units_of_cargo: TTD_STR_CRATES;
        items_of_cargo: TTD_STR_QUANTITY_GOODS;
        cargo_classes: bitmask(CC_EXPRESS, CC_PIECE_GOODS);
        penalty_lowerbound: 16;
        single_penalty_length: 64;
        price_factor: 117;
        weight: 0.5;
        is_freight: 1;
        capacity_multiplier: 2;
        town_growth_effect: TOWNGROWTH_NONE;
        town_growth_multiplier: 1.0;
        sprite: 4302;
    }
}

item (FEAT_CARGOS, item_engineering_supplies) {
    property {
        number: 12;
        type_name: string(STR_CARGO_PLURAL_ENGINEERING_SUPPLIES);
        unit_name: string(STR_CARGO_SINGULAR_ENGINEERING_SUPPLIES);
        type_abbreviation: string(STR_CARGO_ABBREV_ENGINEERING_SUPPLIES);
        cargo_label: "ENGS";
        station_list_colour: 146;
        cargo_payment_list_colour: 146;
        units_of_cargo: string(TTD_STR_CRATES);
        items_of_cargo: string(STR_CARGO_UNIT_ENGINEERING_SUPPLIES);
        cargo_classes: bitmask(CC_EXPRESS,CC_PIECE_GOODS);
        penalty_lowerbound: 20;
        single_penalty_length: 40;
        price_factor: 110;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_engineering_supplies;
    }
}

item (FEAT_CARGOS, item_fertilizer) {
    property {
        number: 13;
        type_name: string(STR_CARGO_PLURAL_FERTILIZER);
        unit_name: string(STR_CARGO_SINGULAR_FERTILIZER);
        type_abbreviation: string(STR_CARGO_ABBREV_FERTILIZER);
        cargo_label: "FERT";
        units_of_cargo: string(TTD_STR_TONS);
        items_of_cargo: string(STR_CARGO_UNIT_FERTILIZER);
        cargo_classes: bitmask(CC_BULK,CC_PIECE_GOODS);
        penalty_lowerbound: 20;
        single_penalty_length: 40;
        price_factor: 151;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_fertilizer;
    }
}

item (FEAT_CARGOS, item_salt) {
    property {
        number: 14;
        type_name: string(STR_CARGO_PLURAL_SALT);
        unit_name: string(STR_CARGO_SINGULAR_SALT);
        type_abbreviation: string(STR_CARGO_ABBREV_SALT);
        cargo_label: "SALT";
        station_list_colour: 48;
        cargo_payment_list_colour: 48;
        units_of_cargo: string(TTD_STR_TONS);
        items_of_cargo: string(STR_CARGO_UNIT_SALT);
        cargo_classes: bitmask(CC_BULK);
        penalty_lowerbound: 30;
        single_penalty_length: 255;
        price_factor: 100;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_salt;
    }
}

item (FEAT_CARGOS, item_potash) {
    property {
        number: 15;
        type_name: string(STR_CARGO_PLURAL_POTASH);
        unit_name: string(STR_CARGO_SINGULAR_POTASH);
        type_abbreviation: string(STR_CARGO_ABBREV_POTASH);
        cargo_label: "PTSH";
        station_list_colour: 13;
        cargo_payment_list_colour: 13;
        units_of_cargo: string(TTD_STR_TONS);
        items_of_cargo: string(STR_CARGO_UNIT_POTASH);
        cargo_classes: bitmask(CC_BULK,CC_COVERED);
        penalty_lowerbound: 30;
        single_penalty_length: 255;
        price_factor: 100;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_potash;
    }
}

item (FEAT_CARGOS, item_sand) {
    property {
        number: 16;
        type_name: string(STR_CARGO_PLURAL_SAND);
        unit_name: string(STR_CARGO_SINGULAR_SAND);
        type_abbreviation: string(STR_CARGO_ABBREV_SAND);
        cargo_label: "SAND";
        station_list_colour: 64;
        cargo_payment_list_colour: 64;
        units_of_cargo: string(TTD_STR_TONS);
        items_of_cargo: string(STR_CARGO_UNIT_SAND);
        cargo_classes: bitmask(CC_BULK);
        penalty_lowerbound: 40;
        single_penalty_length: 255;
        price_factor: 100;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_sand;
    }
}

item (FEAT_CARGOS, item_minerals) {
    property {
        number: 17;
        type_name: string(STR_CARGO_PLURAL_MINERALS);
        unit_name: string(STR_CARGO_SINGULAR_MINERALS);
        type_abbreviation: string(STR_CARGO_ABBREV_MINERALS);
        cargo_label: "MNRL";
        station_list_colour: 41;
        cargo_payment_list_colour: 41;
        units_of_cargo: string(TTD_STR_TONS);
        items_of_cargo: string(STR_CARGO_UNIT_MINERALS);
        cargo_classes: bitmask(CC_BULK);
        penalty_lowerbound: 30;
        single_penalty_length: 255;
        price_factor: 100;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_minerals;
    }
}

item (FEAT_CARGOS, item_corn) {
    property {
        number: 18;
        type_name: string(STR_CARGO_PLURAL_CORN);
        unit_name: string(STR_CARGO_SINGULAR_CORN);
        type_abbreviation: string(STR_CARGO_ABBREV_CORN);
        cargo_label: "CORN";
        station_list_colour: 66;
        cargo_payment_list_colour: 66;
        units_of_cargo: string(TTD_STR_TONS);
        items_of_cargo: string(STR_CARGO_UNIT_CORN);
        cargo_classes: bitmask(CC_COVERED, CC_BULK);
        penalty_lowerbound: 12;
        single_penalty_length: 40;
        price_factor: 90;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_corn;
    }
}

item (FEAT_CARGOS, item_soy) {
    property {
        number: 19;
        type_name: string(STR_CARGO_PLURAL_SOY);
        unit_name: string(STR_CARGO_SINGULAR_SOY);
        type_abbreviation: string(STR_CARGO_ABBREV_SOY);
        cargo_label: "SOYB";
        station_list_colour: 71;
        cargo_payment_list_colour: 71;
        units_of_cargo: string(TTD_STR_TONS);
        items_of_cargo: string(STR_CARGO_UNIT_SOY);
        cargo_classes: bitmask(CC_COVERED, CC_BULK);
        penalty_lowerbound: 8;
        single_penalty_length: 24;
        price_factor: 110;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_soybeans;
    }
}

item (FEAT_CARGOS, item_yam) {
    property {
        number: 20;
        type_name: string(STR_CARGO_PLURAL_YAM);
        unit_name: string(STR_CARGO_SINGULAR_YAM);
        type_abbreviation: string(STR_CARGO_ABBREV_YAM);
        cargo_label: "YAMS";
        station_list_colour: 75;
        cargo_payment_list_colour: 75;
        units_of_cargo: string(TTD_STR_TONS);
        items_of_cargo: string(STR_CARGO_UNIT_YAM);
        cargo_classes: bitmask(CC_COVERED, CC_BULK);
        penalty_lowerbound: 8;
        single_penalty_length: 24;
        price_factor: 110;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_yams;
    }
}

item (FEAT_CARGOS, item_vials) {
    property {
        number: 21;
        type_name: string(STR_CARGO_PLURAL_VIALS);
        unit_name: string(STR_CARGO_SINGULAR_VIALS);
        type_abbreviation: string(STR_CARGO_ABBREV_VIALS);
        cargo_label: "VIAL";
        station_list_colour: 135;
        cargo_payment_list_colour: 135;
        units_of_cargo: string(TTD_STR_CRATES);
        items_of_cargo: string(STR_CARGO_UNIT_VIALS);
        cargo_classes: bitmask(CC_PIECE_GOODS);
        penalty_lowerbound: 16;
        single_penalty_length: 160;
        price_factor: 117;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_vials;
    }
}

item (FEAT_CARGOS, item_chemicals) {
    property {
        number: 22;
        type_name: string(STR_CARGO_PLURAL_CHEMICALS);
        unit_name: string(STR_CARGO_SINGULAR_CHEMICALS);
        type_abbreviation: string(STR_CARGO_ABBREV_CHEMICALS);
        cargo_label: "CHEM";
        station_list_colour: 185;
        cargo_payment_list_colour: 185;
        units_of_cargo: string(TTD_STR_LITERS);
        items_of_cargo: string(STR_CARGO_UNIT_CHEMICALS);
        cargo_classes: bitmask(CC_LIQUID, CC_HAZARDOUS);
        penalty_lowerbound: 24;
        single_penalty_length: 48;
        price_factor: 198;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_chemicals;
    }
}

item (FEAT_CARGOS, item_vegetable_oil) {
    property {
        number: 23;
        type_name: string(STR_CARGO_PLURAL_VEGETABLE_OIL);
        unit_name: string(STR_CARGO_SINGULAR_VEGETABLE_OIL);
        type_abbreviation: string(STR_CARGO_ABBREV_VEGETABLE_OIL);
        cargo_label: "VGOL";
        station_list_colour: 206;
        cargo_payment_list_colour: 206;
        units_of_cargo: string(TTD_STR_LITERS);
        items_of_cargo: string(STR_CARGO_UNIT_VEGETABLE_OIL);
        cargo_classes: bitmask(CC_LIQUID);
        penalty_lowerbound: 8;
        single_penalty_length: 36;
        price_factor: 110;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_vegetable_oil;
    }
}

item (FEAT_CARGOS, item_alcohol) {
    property {
        number: 24;
        type_name: string(STR_CARGO_PLURAL_ALCOHOL);
        unit_name: string(STR_CARGO_SINGULAR_ALCOHOL);
        type_abbreviation: string(STR_CARGO_ABBREV_ALCOHOL);
        cargo_label: "ALCH";
        station_list_colour: 192;
        cargo_payment_list_colour: 192;
        units_of_cargo: string(TTD_STR_LITERS);
        items_of_cargo: string(STR_CARGO_UNIT_ALCOHOL);
        cargo_classes: bitmask(CC_LIQUID);
        penalty_lowerbound: 12;
        single_penalty_length: 40;
        price_factor: 110;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_alcohol;
    }
}

item (FEAT_CARGOS, item_diosgenin) {
    property {
        number: 25;
        type_name: string(STR_CARGO_PLURAL_DIOSGENIN);
        unit_name: string(STR_CARGO_SINGULAR_DIOSGENIN);
        type_abbreviation: string(STR_CARGO_ABBREV_DIOSGENIN);
        cargo_label: "DIOS";
        station_list_colour: 133;
        cargo_payment_list_colour: 133;
        units_of_cargo: string(TTD_STR_CRATES);
        items_of_cargo: string(STR_CARGO_UNIT_DIOSGENIN);
        cargo_classes: bitmask(CC_REFRIGERATED, CC_BULK);
        penalty_lowerbound: 32;
        single_penalty_length: 40;
        price_factor: 360;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_diosgenin;
    }
}

item (FEAT_CARGOS, item_raw_estrone) {
    property {
        number: 26;
        type_name: string(STR_CARGO_PLURAL_RAW_ESTRONE);
        unit_name: string(STR_CARGO_SINGULAR_RAW_ESTRONE);
        type_abbreviation: string(STR_CARGO_ABBREV_RAW_ESTRONE);
        cargo_label: "RWES";
        station_list_colour: 152;
        cargo_payment_list_colour: 152;
        units_of_cargo: string(TTD_STR_CRATES);
        items_of_cargo: string(STR_CARGO_UNIT_RAW_ESTRONE);
        cargo_classes: bitmask(CC_REFRIGERATED, CC_BULK);
        penalty_lowerbound: 32;
        single_penalty_length: 140;
        price_factor: 180;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_raw_estrone;
    }
}

item (FEAT_CARGOS, item_raw_testosterone) {
    property {
        number: 27;
        type_name: string(STR_CARGO_PLURAL_RAW_TESTOSTERONE);
        unit_name: string(STR_CARGO_SINGULAR_RAW_TESTOSTERONE);
        type_abbreviation: string(STR_CARGO_ABBREV_RAW_TESTOSTERONE);
        cargo_label: "RWTS";
        station_list_colour: 103;
        cargo_payment_list_colour: 103;
        units_of_cargo: string(TTD_STR_CRATES);
        items_of_cargo: string(STR_CARGO_UNIT_RAW_TESTOSTERONE);
        cargo_classes: bitmask(CC_REFRIGERATED, CC_BULK);
        penalty_lowerbound: 32;
        single_penalty_length: 140;
        price_factor: 180;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_raw_testosterone;
    }
}

item (FEAT_CARGOS, item_estrogen) {
    property {
        number: 28;
        type_name: string(STR_CARGO_PLURAL_ESTROGEN);
        unit_name: string(STR_CARGO_SINGULAR_ESTROGEN);
        type_abbreviation: string(STR_CARGO_ABBREV_ESTROGEN);
        cargo_label: "ESTR";
        station_list_colour: 150;
        cargo_payment_list_colour: 150;
        units_of_cargo: string(TTD_STR_CRATES);
        items_of_cargo: string(STR_CARGO_UNIT_ESTROGEN);
        cargo_classes: bitmask(CC_PIECE_GOODS);
        penalty_lowerbound: 12;
        single_penalty_length: 32;
        price_factor: 380;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_estrogen;
    }
    
}

item (FEAT_CARGOS, item_testosterone) {
    property {
        number: 29;
        type_name: string(STR_CARGO_PLURAL_TESTOSTERONE);
        unit_name: string(STR_CARGO_SINGULAR_TESTOSTERONE);
        type_abbreviation: string(STR_CARGO_ABBREV_TESTOSTERONE);
        cargo_label: "TEST";
        station_list_colour: 101;
        cargo_payment_list_colour: 101;
        units_of_cargo: string(TTD_STR_CRATES);
        items_of_cargo: string(STR_CARGO_UNIT_TESTOSTERONE);
        cargo_classes: bitmask(CC_PIECE_GOODS);
        penalty_lowerbound: 13;
        single_penalty_length: 32;
        price_factor: 380;
        weight: 1.0;
        is_freight: 1.0;
        capacity_multiplier: 1;
        sprite: NEW_CARGO_SPRITE;
    }
    graphics {
        default: sprite_testosterone;
    }
}

// ----------------------------------------------------------------
// ||||||||||||||||||||| Industry Definitions |||||||||||||||||||||
// ----------------------------------------------------------------
// Industry Tiles
// --------------------------------


// Randomize FEAT_INDUSTRY PERM Register 96 using FEAT_INDUSTRYTILES randomization every 256 ticks
// --------------------------------
random_switch(FEAT_INDUSTRYTILES, SELF, randomize_bit_0, bitmask(TRIGGER_INDUSTRYTILE_256_TICKS)) {
    1: return 0;
    1: return 1;
}

random_switch(FEAT_INDUSTRYTILES, SELF, randomize_bit_1, bitmask(TRIGGER_INDUSTRYTILE_256_TICKS)) {
    dependent: randomize_bit_0;
    1: return 0;
    1: return 1;
}

random_switch(FEAT_INDUSTRYTILES, SELF, randomize_bit_2, bitmask(TRIGGER_INDUSTRYTILE_256_TICKS)) {
    dependent: randomize_bit_0;
    dependent: randomize_bit_1;
    1: return 0;
    1: return 1;
}

random_switch(FEAT_INDUSTRYTILES, SELF, randomize_bit_3, bitmask(TRIGGER_INDUSTRYTILE_256_TICKS)) {
    dependent: randomize_bit_0;
    dependent: randomize_bit_1;
    dependent: randomize_bit_2;
    1: return 0;
    1: return 1;
}

random_switch(FEAT_INDUSTRYTILES, SELF, randomize_bit_4, bitmask(TRIGGER_INDUSTRYTILE_256_TICKS)) {
    dependent: randomize_bit_0;
    dependent: randomize_bit_1;
    dependent: randomize_bit_2;
    dependent: randomize_bit_3;
    1: return 0;
    1: return 1;
}

random_switch(FEAT_INDUSTRYTILES, SELF, randomize_bit_5, bitmask(TRIGGER_INDUSTRYTILE_256_TICKS)) {
    dependent: randomize_bit_0;
    dependent: randomize_bit_1;
    dependent: randomize_bit_2;
    dependent: randomize_bit_3;
    dependent: randomize_bit_4;
    1: return 0;
    1: return 1;
}

random_switch(FEAT_INDUSTRYTILES, SELF, randomize_bit_6, bitmask(TRIGGER_INDUSTRYTILE_256_TICKS)) {
    dependent: randomize_bit_0;
    dependent: randomize_bit_1;
    dependent: randomize_bit_2;
    dependent: randomize_bit_3;
    dependent: randomize_bit_4;
    dependent: randomize_bit_5;
    1: return 0;
    1: return 1;
}

random_switch(FEAT_INDUSTRYTILES, SELF, randomize_bit_7, bitmask(TRIGGER_INDUSTRYTILE_256_TICKS)) {
    dependent: randomize_bit_0;
    dependent: randomize_bit_1;
    dependent: randomize_bit_2;
    dependent: randomize_bit_3;
    dependent: randomize_bit_4;
    dependent: randomize_bit_5;
    dependent: randomize_bit_6;
    1: return 0;
    1: return 1;
}

switch(FEAT_INDUSTRYTILES, PARENT, trigger_randomize_bits_helper, [
    // Tags: #random #helper
    //
    // Generate an independently randomized bit and store it
    // into each bit of FEAT_INDUSTRIES PERM Register 96.
    // :return: Arbitrary number to satisfy trigger callback

    STORE_PERM(     (randomize_bit_0() * 128) +
                    (randomize_bit_1() * 64) +
                    (randomize_bit_2() * 32) +
                    (randomize_bit_3() * 16) +
                    (randomize_bit_4() * 8) +
                    (randomize_bit_5() * 4) +
                    (randomize_bit_6() * 2) +
                    (randomize_bit_7() * 1),
                    96
    )
]) {
    return 0;
}

random_switch(FEAT_INDUSTRYTILES, PARENT, trigger_randomize_bits, bitmask(TRIGGER_INDUSTRYTILE_256_TICKS)) {
    1: trigger_randomize_bits_helper;
}
// --------------------------------


// Define tile check functions to determine industry spawn validity
// ----------------------------------------------------------------
switch(FEAT_INDUSTRYTILES, SELF, tile_check_is_water, [
    // Check to see if the current tile is a water tile.
    // :return: CB_RESULT_LOCATION_ALLOW if condition satisfied, CB_RESULT_LOCATION_DISALLOW if not.

    nearby_tile_class(0,0)
]) {
    TILE_CLASS_WATER: return CB_RESULT_LOCATION_ALLOW;
    return CB_RESULT_LOCATION_DISALLOW;
}

switch(FEAT_INDUSTRYTILES, SELF, tile_check_is_ground, [
    // Check to see if the current tile is a ground tile.
    // :return: CB_RESULT_LOCATION_ALLOW if condition satisfied, CB_RESULT_LOCATION_DISALLOW if not.

    nearby_tile_class(0,0)
]) {
    TILE_CLASS_GROUND: return CB_RESULT_LOCATION_ALLOW;
    return CB_RESULT_LOCATION_DISALLOW;
}

switch(FEAT_INDUSTRYTILES, SELF, tile_check_is_level, [
    // Iterate through each neighboring tile and ensure that they are the same height.
    // :return: CB_RESULT_LOCATION_ALLOW if condition satisfied, CB_RESULT_LOCATION_DISALLOW if not.

    (   (nearby_tile_height(0,0) == nearby_tile_height(-1,-1)) *
        (nearby_tile_height(0,0) == nearby_tile_height(-1,0)) *
        (nearby_tile_height(0,0) == nearby_tile_height(-1,1)) *
        (nearby_tile_height(0,0) == nearby_tile_height(0,-1)) *
        (nearby_tile_height(0,0) == nearby_tile_height(0,1)) *
        (nearby_tile_height(0,0) == nearby_tile_height(1,-1)) *
        (nearby_tile_height(0,0) == nearby_tile_height(1,0)) *
        (nearby_tile_height(0,0) == nearby_tile_height(1,1))
    )
]) {
    1: CB_RESULT_LOCATION_ALLOW;
    return CB_RESULT_LOCATION_DISALLOW;
}

switch(FEAT_INDUSTRYTILES, SELF, tile_check_is_immersed, [
    // Check to see if the current tile is surrounded by water tiles.
    // :return: CB_RESULT_LOCATION_ALLOW if condition satisfied, CB_RESULT_LOCATION_DISALLOW if not.

    (   (nearby_tile_class(-1,-1) == TILE_CLASS_WATER) *
        (nearby_tile_class(-1,0) == TILE_CLASS_WATER) *
        (nearby_tile_class(-1,1) == TILE_CLASS_WATER) *
        (nearby_tile_class(0,-1) == TILE_CLASS_WATER) *
        (nearby_tile_class(0,1) == TILE_CLASS_WATER) *
        (nearby_tile_class(1,-1) == TILE_CLASS_WATER) *
        (nearby_tile_class(1,0) == TILE_CLASS_WATER) *
        (nearby_tile_class(1,1) == TILE_CLASS_WATER)
    )
]) {
    1: return CB_RESULT_LOCATION_ALLOW;
    return CB_RESULT_LOCATION_DISALLOW;
}

switch(FEAT_INDUSTRYTILES, SELF, tile_check_is_adjacent_ground, [
    // Check to see if the current tile is adjacent to a ground tile.
    // :return: CB_RESULT_LOCATION_ALLOW if condition satisfied, CB_RESULT_LOCATION_DISALLOW if not.

    (   (nearby_tile_class(-1,-1) == TILE_CLASS_GROUND) +
        (nearby_tile_class(-1,0) == TILE_CLASS_GROUND) +
        (nearby_tile_class(-1,1) == TILE_CLASS_GROUND) +
        (nearby_tile_class(0,-1) == TILE_CLASS_GROUND) +
        (nearby_tile_class(0,1) == TILE_CLASS_GROUND) +
        (nearby_tile_class(1,-1) == TILE_CLASS_GROUND) +
        (nearby_tile_class(1,0) == TILE_CLASS_GROUND) +
        (nearby_tile_class(1,1) == TILE_CLASS_GROUND)
    )
]) {
    1: return CB_RESULT_LOCATION_ALLOW;
    return CB_RESULT_LOCATION_DISALLOW;
}

switch(FEAT_INDUSTRYTILES, SELF, tile_check_level_ground, [
    // Check to see if the current tile is level and ground.
    // :return: CB_RESULT_LOCATION_ALOW if location satisfied, CB_RESULT_LOCATION_DISALLOW if not.

    tile_check_is_level()
]) {
    CB_RESULT_LOCATION_ALLOW: tile_check_is_ground;
    return CB_RESULT_LOCATION_DISALLOW;
}

switch(FEAT_INDUSTRYTILES, SELF, tile_check_level_water, [
    // Check to see if the current tile is water and level.
    // :return: CB_RESULT_LOCATION_ALLOW if condition satisfied, CB_RESULT_LOCATION_DISALLOW if not.

    tile_check_is_level()
]) {
    CB_RESULT_LOCATION_ALLOW: tile_check_is_water;
    return CB_RESULT_LOCATION_DISALLOW;
}

switch(FEAT_INDUSTRYTILES, SELF, tile_check_deep_water, [
    // Check to see if the current tile is water and surrounded by water.
    // :return: CB_RESULT_LOCATION_ALLOW if condition satisfied, CB_RESULT_LOCATION_DISALLOW if not.

    tile_check_is_immersed()
]) {
    CB_RESULT_LOCATION_ALLOW: tile_check_is_water;
    return CB_RESULT_LOCATION_DISALLOW;
}
// ----------------------------------------------------------------

// Define tiles and layouts that make up the industries.
// ----------------------------------------------------------------
spritelayout spritelayout_placeholder_water {
    ground {
        sprite: GROUNDSPRITE_CONCRETE;
    }
}

item(FEAT_INDUSTRYTILES, tile_placeholder_water) {
    property {
        substitute: 0;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
        land_shape_flags: bitmask(LSF_ALLOW_ON_WATER);
    }
    graphics {
        default: spritelayout_placeholder_water;
        tile_check: tile_check_level_water;
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_placeholder_deep_water) {
    property {
        substitute: 0;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
        land_shape_flags: bitmask(LSF_ALLOW_ON_WATER);
    }
    graphics {
        default: spritelayout_placeholder_water;
        tile_check: tile_check_deep_water;
        random_trigger: trigger_randomize_bits;
    }
}

spritelayout spritelayout_placeholder_ground {
    ground {
        sprite: GROUNDSPRITE_NORMAL;
    }
    building {
        sprite: 4698;
    }
}

spritelayout spritelayout_placeholder_beach {
    ground {
        sprite: GROUNDSPRITE_NORMAL;
    }
    building {
        sprite: 2174;
    }
}

item(FEAT_INDUSTRYTILES, tile_placeholder_ground) {
    property {
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
        land_shape_flags: bitmask(LSF_ONLY_ON_FLAT_LAND);
    }
    graphics {
        default: spritelayout_placeholder_ground;
        tile_check: tile_check_level_ground;
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_placeholder_beach) {
    property {
        substitute: 0;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
        land_shape_flags: bitmask(LSF_ALLOW_ON_WATER);
    }
    graphics {
        default: spritelayout_placeholder_beach;
        tile_check: tile_check_is_adjacent_ground;
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_33) {
    property {
        substitute: 33;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_34) {
    property {
        substitute: 34;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_35) {
    property {
        substitute: 35;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_36) {
    property {
        substitute: 36;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_37) {
    property {
        substitute: 37;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_38) {
    property {
        substitute: 38;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

tilelayout layout_farm_vertical {
    0,0: tile_replace_33;
    0,1: tile_replace_34;
    1,0: tile_replace_35;
    1,1: tile_replace_36;
    2,0: tile_replace_37;
    2,1: tile_replace_38;
}

tilelayout layout_farm_horizontal {
    0,0: tile_replace_33;
    0,1: tile_replace_34;
    0,2: tile_replace_35;
    1,0: tile_replace_36;
    2,1: tile_replace_37;
    2,2: tile_replace_38;
}

tilelayout layout_default {
    0,0: tile_placeholder_ground;
    0,1: tile_placeholder_ground;
    0,2: tile_placeholder_ground;
    1,0: tile_placeholder_ground;
    1,1: tile_placeholder_ground;
    1,2: tile_placeholder_ground;
    2,0: tile_placeholder_ground;
    2,1: tile_placeholder_ground;
    2,2: tile_placeholder_ground;
    3,0: tile_placeholder_ground;
    3,1: tile_placeholder_ground;
    3,2: tile_placeholder_ground;
}

tilelayout layout_coast_north {
    0,0: tile_placeholder_beach;
    0,1: tile_placeholder_beach;
    1,0: tile_placeholder_water;
    1,1: tile_placeholder_water;
    2,0: tile_placeholder_deep_water;
    2,1: tile_placeholder_deep_water;
    3,0: tile_placeholder_deep_water;
    3,1: tile_placeholder_deep_water;
}

tilelayout layout_coast_south {
    0,0: tile_placeholder_deep_water;
    0,1: tile_placeholder_deep_water;
    1,0: tile_placeholder_deep_water;
    1,1: tile_placeholder_deep_water;
    2,0: tile_placeholder_water;
    2,1: tile_placeholder_water;
    3,0: tile_placeholder_beach;
    3,1: tile_placeholder_beach;
}

tilelayout layout_coast_east {
    0,0: tile_placeholder_beach;
    1,0: tile_placeholder_beach;
    0,1: tile_placeholder_water;
    1,1: tile_placeholder_water;
    0,2: tile_placeholder_deep_water;
    1,2: tile_placeholder_deep_water;
    0,3: tile_placeholder_deep_water;
    1,3: tile_placeholder_deep_water;
}

tilelayout layout_coast_west {
    0,0: tile_placeholder_deep_water;
    1,0: tile_placeholder_deep_water;
    0,1: tile_placeholder_water;
    1,1: tile_placeholder_water;
    0,2: tile_placeholder_water;
    1,2: tile_placeholder_water;
    0,3: tile_placeholder_beach;
    1,3: tile_placeholder_beach;
}

item(FEAT_INDUSTRYTILES, tile_replace_110) {
    property {
        substitute: 110;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

tilelayout layout_quarry {
    0,0: tile_replace_110;
    1,0: tile_replace_110;
    2,0: tile_replace_110;
    0,1: tile_replace_110;
    1,1: tile_replace_110;
    2,1: tile_replace_110;
    0,2: tile_replace_110;
    1,2: tile_replace_110;
    2,2: tile_replace_110;
}

item(FEAT_INDUSTRYTILES, tile_replace_101) {
    property {
        substitute: 101;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_102) {
    property {
        substitute: 102;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_104) {
    property {
        substitute: 104;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_106) {
    property {
        substitute: 106;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_108) {
    property {
        substitute: 108;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_109) {
    property {
        substitute: 109;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

tilelayout layout_mineral_mine {
    0,1: tile_replace_101;
    0,2: tile_replace_102;
    1,1: tile_replace_104;
    1,2: tile_replace_106;
    2,1: tile_replace_108;
    2,2: tile_replace_109;
}

item(FEAT_INDUSTRYTILES, tile_replace_39) {
    property {
        substitute: 39;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_40) {
    property {
        substitute: 40;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_41) {
    property {
        substitute: 41;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_42) {
    property {
        substitute: 42;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

tilelayout layout_glassworks {
    0,0: tile_replace_39;
    0,1: tile_replace_40;
    1,0: tile_replace_41;
    1,1: tile_replace_42;
}

item(FEAT_INDUSTRYTILES, tile_replace_18) {
    property {
        substitute: 18;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_19) {
    property {
        substitute: 19;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_20) {
    property {
        substitute: 20;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_21) {
    property {
        substitute: 21;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_22) {
    property {
        substitute: 22;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_23) {
    property {
        substitute: 23;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

tilelayout layout_chemical_plant {
    0,0: tile_replace_18;
    0,1: tile_replace_19;
    1,0: tile_replace_20;
    1,1: tile_replace_21;
    2,0: tile_replace_22;
    2,1: tile_replace_23;
}

item(FEAT_INDUSTRYTILES, tile_replace_121) {
    property {
        substitute: 121;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_122) {
    property {
        substitute: 122;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_123) {
    property {
        substitute: 123;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_124) {
    property {
        substitute: 124;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

tilelayout layout_processing_plant {
    0,0: tile_replace_121;
    0,1: tile_replace_122;
    1,0: tile_replace_123;
    1,1: tile_replace_124;
}

item(FEAT_INDUSTRYTILES, tile_replace_120) {
    property {
        substitute: 120;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}


tilelayout layout_distillery {
    0,0: tile_replace_120;
    0,1: tile_replace_120;
    1,0: tile_replace_120;
    1,1: tile_replace_120;
}

item(FEAT_INDUSTRYTILES, tile_replace_60) {
    property {
        substitute: 60;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_61) {
    property {
        substitute: 61;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_62) {
    property {
        substitute: 62;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_63) {
    property {
        substitute: 63;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

tilelayout layout_biolab {
    0,0: tile_replace_60;
    0,1: tile_replace_61;
    1,0: tile_replace_62;
    1,1: tile_replace_63;
}

item(FEAT_INDUSTRYTILES, tile_replace_52) {
    property {
        substitute: 52;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_53) {
    property {
        substitute: 53;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_54) {
    property {
        substitute: 54;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_55) {
    property {
        substitute: 55;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

tilelayout layout_pharmaceutical_plant {
    0,0: tile_replace_52;
    0,1: tile_replace_53;
    1,0: tile_replace_54;
    1,1: tile_replace_55;
    2,0: tile_replace_52;
    2,1: tile_replace_53;
}

item(FEAT_INDUSTRYTILES, tile_replace_58) {
    property {
        substitute: 58;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

item(FEAT_INDUSTRYTILES, tile_replace_59) {
    property {
        substitute: 59;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

tilelayout layout_pharmacy {
    0,0: tile_replace_58;
    1,0: tile_replace_59;
}

item(FEAT_INDUSTRYTILES, tile_replace_60) {
    property {
        substitute: 60;
        special_flags: bitmask(INDTILE_FLAG_ACCEPT_ALL);
    }
    graphics {
        random_trigger: trigger_randomize_bits;
    }
}

tilelayout layout_gender_clinic {
    0,0: tile_replace_60;
}
// --------------------------------


// ----------------------------------------------------------------
// Industry Scripts
// --------------------------------


// Industry Addressing Reference
// ----------------------------------------------------------------
// PERM_000         :Production cycle index (0..26)
// PERM_001..028    :Input Cargo 0 delivered last 27 cycles (+1 sum @ PERM_028)
// PERM_029..056    :Input Cargo 1 delivered last 27 cycles (+1 sum @ PERM_056)
// PERM_057..084    :Input Cargo 2 delivered last 27 cycles (+1 sum @ PERM_084)
// PERM_085         :Seasons without cargo
// PERM_086         :Seasons with consistent cargo
// PERM_087         :Production level       {0: Closed; 1: Ruin -2; 2: Ruin -1; 3: Default; 4: Progress +1; 5: Progress +2; 6: Progress +3}
// PERM_088         :Random production variance
// PERM_089         :Season                 (0..3)
// PERM_090         :Supplied multiplier    {1, 2, 4}
// PERM_091         :Combo multiplier       {1, 2, 4}
// PERM_092         :Months left of "recently extracted' state      (0..3)
// PERM_093..095    :Seasonal service       (0..100)
// PERM_096         :Random industrytiles bits      (0..255)
// PERM_097         :Whether this industry has ever been serviced.  {0, 1}
// PERM_098         :Linear Shift Feedback Register
// PERM_099         :Psuedo-random bits     (0..255)
// PERM_100..127    :Unassigned
//
// TEMP_000..031    :Parameter argument registers
// TEMP_032..063    :Parameter return registers
// TEMP_064..0127   :Internal registers for in-function calculations
// TEMP_128..255    :Unassigned
// TEMP_256..275    :Textstack
// --------------------------------

switch(FEAT_INDUSTRIES, SELF, load_perm_variable, index, index) {
    // Only possible method to LOAD a variable address from PERM Registers.
    // I don't like it either.
    // :param index: PERM Register address to access (0..127)
    // :return: value within specified PERM Register

    0: LOAD_PERM(0);
    1: LOAD_PERM(1);
    2: LOAD_PERM(2);
    3: LOAD_PERM(3);
    4: LOAD_PERM(4);
    5: LOAD_PERM(5);
    6: LOAD_PERM(6);
    7: LOAD_PERM(7);
    8: LOAD_PERM(8);
    9: LOAD_PERM(9);
    10: LOAD_PERM(10);
    11: LOAD_PERM(11);
    12: LOAD_PERM(12);
    13: LOAD_PERM(13);
    14: LOAD_PERM(14);
    15: LOAD_PERM(15);
    16: LOAD_PERM(16);
    17: LOAD_PERM(17);
    18: LOAD_PERM(18);
    19: LOAD_PERM(19);
    20: LOAD_PERM(20);
    21: LOAD_PERM(21);
    22: LOAD_PERM(22);
    23: LOAD_PERM(23);
    24: LOAD_PERM(24);
    25: LOAD_PERM(25);
    26: LOAD_PERM(26);
    27: LOAD_PERM(27);
    28: LOAD_PERM(28);
    29: LOAD_PERM(29);
    30: LOAD_PERM(30);
    31: LOAD_PERM(31);
    32: LOAD_PERM(32);
    33: LOAD_PERM(33);
    34: LOAD_PERM(34);
    35: LOAD_PERM(35);
    36: LOAD_PERM(36);
    37: LOAD_PERM(37);
    38: LOAD_PERM(38);
    39: LOAD_PERM(39);
    40: LOAD_PERM(40);
    41: LOAD_PERM(41);
    42: LOAD_PERM(42);
    43: LOAD_PERM(43);
    44: LOAD_PERM(44);
    45: LOAD_PERM(45);
    46: LOAD_PERM(46);
    47: LOAD_PERM(47);
    48: LOAD_PERM(48);
    49: LOAD_PERM(49);
    50: LOAD_PERM(50);
    51: LOAD_PERM(51);
    52: LOAD_PERM(52);
    53: LOAD_PERM(53);
    54: LOAD_PERM(54);
    55: LOAD_PERM(55);
    56: LOAD_PERM(56);
    57: LOAD_PERM(57);
    58: LOAD_PERM(58);
    59: LOAD_PERM(59);
    60: LOAD_PERM(60);
    61: LOAD_PERM(61);
    62: LOAD_PERM(62);
    63: LOAD_PERM(63);
    64: LOAD_PERM(64);
    65: LOAD_PERM(65);
    66: LOAD_PERM(66);
    67: LOAD_PERM(67);
    68: LOAD_PERM(68);
    69: LOAD_PERM(69);
    70: LOAD_PERM(70);
    71: LOAD_PERM(71);
    72: LOAD_PERM(72);
    73: LOAD_PERM(73);
    74: LOAD_PERM(74);
    75: LOAD_PERM(75);
    76: LOAD_PERM(76);
    77: LOAD_PERM(77);
    78: LOAD_PERM(78);
    79: LOAD_PERM(79);
    80: LOAD_PERM(80);
    81: LOAD_PERM(81);
    82: LOAD_PERM(82);
    83: LOAD_PERM(83);
    84: LOAD_PERM(84);
    85: LOAD_PERM(85);
    86: LOAD_PERM(86);
    87: LOAD_PERM(87);
    88: LOAD_PERM(88);
    89: LOAD_PERM(89);
    90: LOAD_PERM(90);
    91: LOAD_PERM(91);
    92: LOAD_PERM(92);
    93: LOAD_PERM(93);
    94: LOAD_PERM(94);
    95: LOAD_PERM(95);
    96: LOAD_PERM(96);
    97: LOAD_PERM(97);
    98: LOAD_PERM(98);
    99: LOAD_PERM(99);
    100: LOAD_PERM(100);
    101: LOAD_PERM(101);
    102: LOAD_PERM(102);
    103: LOAD_PERM(103);
    104: LOAD_PERM(104);
    105: LOAD_PERM(105);
    106: LOAD_PERM(106);
    107: LOAD_PERM(107);
    108: LOAD_PERM(108);
    109: LOAD_PERM(109);
    110: LOAD_PERM(110);
    111: LOAD_PERM(111);
    112: LOAD_PERM(112);
    113: LOAD_PERM(113);
    114: LOAD_PERM(114);
    115: LOAD_PERM(115);
    116: LOAD_PERM(116);
    117: LOAD_PERM(117);
    118: LOAD_PERM(118);
    119: LOAD_PERM(119);
    120: LOAD_PERM(120);
    121: LOAD_PERM(121);
    122: LOAD_PERM(122);
    123: LOAD_PERM(123);
    124: LOAD_PERM(124);
    125: LOAD_PERM(125);
    126: LOAD_PERM(126);
    127: LOAD_PERM(127);
}

// Generate pseudo-random 8-bit numbers using a Linear Shift Feedback Register.
// ----------------------------------------------------------------
random_switch(FEAT_INDUSTRIES, SELF, init_rand_nibble_1) {
    // Tags: #random #helper
    //
    // Use the iniitally generated random bits in the industry to seed the LSF Register.
    // :return: Random nibble

    1: return 0;
    1: return 1;
    1: return 2;
    1: return 3;
    1: return 4;
    1: return 5;
    1: return 6;
    1: return 7;
    1: return 8;
    1: return 9;
    1: return 10;
    1: return 11;
    1: return 12;
    1: return 13;
    1: return 14;
    1: return 15;
}

random_switch(FEAT_INDUSTRIES, SELF, init_rand_nibble_2) {
    // Tags: #random #helper
    //
    // Use the iniitally generated random bits in the industry to seed the LSF Register.
    // :return: Random nibble

    dependent: init_rand_nibble_1;
    1: return 0;
    1: return 1;
    1: return 2;
    1: return 3;
    1: return 4;
    1: return 5;
    1: return 6;
    1: return 7;
    1: return 8;
    1: return 9;
    1: return 10;
    1: return 11;
    1: return 12;
    1: return 13;
    1: return 14;
    1: return 15;
}

random_switch(FEAT_INDUSTRIES, SELF, init_rand_nibble_3) {
    // Tags: #random #helper
    //
    // Use the iniitally generated random bits in the industry to seed the LSF Register.
    // :return: Random nibble

    dependent: init_rand_nibble_1;
    dependent: init_rand_nibble_2;
    1: return 0;
    1: return 1;
    1: return 2;
    1: return 3;
    1: return 4;
    1: return 5;
    1: return 6;
    1: return 7;
    1: return 8;
    1: return 9;
    1: return 10;
    1: return 11;
    1: return 12;
    1: return 13;
    1: return 14;
    1: return 15;
}

random_switch(FEAT_INDUSTRIES, SELF, init_rand_nibble_4) {
    // Tags: #random #helper
    //
    // Use the iniitally generated random bits in the industry to seed the LSF Register.
    // :return: Random nibble

    dependent: init_rand_nibble_1;
    dependent: init_rand_nibble_2;
    dependent: init_rand_nibble_3;
    1: return 0;
    1: return 1;
    1: return 2;
    1: return 3;
    1: return 4;
    1: return 5;
    1: return 6;
    1: return 7;
    1: return 8;
    1: return 9;
    1: return 10;
    1: return 11;
    1: return 12;
    1: return 13;
    1: return 14;
    1: return 15;
}

switch(FEAT_INDUSTRIES, SELF, init_lsfr, [
    // Tags: #random
    // PERM 098: Linear Shift Feedback Register
    //
    // Use the iniitally generated random bits in the industry to seed the LSF Register.
    // :return: Randomized 16 bits

    STORE_PERM(
                (init_rand_nibble_1() << 0) |
                (init_rand_nibble_2() << 4) |
                (init_rand_nibble_3() << 8) |
                (init_rand_nibble_4() << 12)
        , 98)
]) {
    return LOAD_PERM(98);
}

switch(FEAT_INDUSTRIES, SELF, lsfr_stream, [
    // Tags: #random
    // TEMP 064: XOR'd tap bits
    // PERM 098: Linear Shift Feedback Register
    //
    // Generate a stream of pseudo-random bits each time called
    // :return: Pseudo-random bits

    STORE_TEMP(
            ((LOAD_PERM(98) >> 0) ^ 
            (LOAD_PERM(98) >> 2) ^ 
            (LOAD_PERM(98) >> 3) ^ 
            (LOAD_PERM(98) >> 5)) & 1
        , 64),
    STORE_PERM((LOAD_PERM(98) >> 1) | (LOAD_TEMP(64) << 15), 98)
]) {
    return LOAD_PERM(98) & 1;
}

switch(FEAT_INDUSTRIES, SELF, lsfr_byte_stream, [
    // Tags: #random
    // TEMP 064: XOR'd tap bits
    // PERM 099: Pseudorandom byte
    //
    // Generate a stream of pseudo-random bytes each time called
    // :return: Pseudo-random byte

    STORE_PERM(
            ((lsfr_stream() << 0) |
            (lsfr_stream() << 1) |
            (lsfr_stream() << 2) |
            (lsfr_stream() << 3) |
            (lsfr_stream() << 4) |
            (lsfr_stream() << 5) |
            (lsfr_stream() << 6) |
            (lsfr_stream() << 7)) & 255
        , 99)
]) {
    return LOAD_PERM(99);
}

switch(FEAT_INDUSTRIES, SELF, is_isolated, radius, [
    // Tags: #hardcoded
    //
    // Determine if this industry is far enough away from all other industries.
    // :param radius: Minimum distance required to be considered isolated.
    // :return: CB_RESULT_LOCATION_ALLOW if condition met, CB_RESULT_LOCATION_DISALLOW if not.

    (   (industry_distance(0) > radius) *
        (industry_distance(1) > radius) *
        (industry_distance(2) > radius) *
        (industry_distance(3) > radius) *
        (industry_distance(4) > radius) *
        (industry_distance(5) > radius) *
        (industry_distance(6) > radius) *
        (industry_distance(7) > radius) *
        (industry_distance(8) > radius) *
        (industry_distance(9) > radius) *
        (industry_distance(10) > radius) *
        (industry_distance(11) > radius) *
        (industry_distance(12) > radius) *
        (industry_distance(13) > radius) *
        (industry_distance(14) > radius) *
        (industry_distance(15) > radius) *
        (industry_distance(16) > radius)
    )
]) {
    1: return CB_RESULT_LOCATION_ALLOW;
    return CB_RESULT_LOCATION_DISALLOW;

}

switch(FEAT_INDUSTRIES, SELF, check_nonzero, index, load_perm_variable(index)) {
    // Determine if the value within the specified PERM Register is nonzero.
    // :param index: PERM Register address to check.
    // :return: 0 if 0, 1 if not.
    
    0: return 0;
    return 1;
}

switch(FEAT_INDUSTRIES, SELF, extraction_ratio, LOAD_PERM(28)) {
    // PERM 028: Total Input Cargo 0 delivered in the last season.
    //
    // Get a Primary Industry's Extraction Ratio.
    // :return: Ratio to multiply this industry's monthly production by.

    0..19: return 1;
    20..79: return 2;
    return 4;
}

switch(FEAT_INDUSTRIES, SELF, conversion_ratio, [
    // Get a Secondary Industry's Conversion Ratio based on unique cargoes supplied last season.
    // :return: Ratio to multiply this industry's conversion rate by.
    check_nonzero(28) + check_nonzero(56) + check_nonzero(84)
]) {
    3: return 4;
    2: return 2;
    return 1;
}

switch(FEAT_INDUSTRIES, SELF, apply_production_modifiers, expected_value, multiplier, [
    // Tags: #hardcoded
    // PERM 087: Current Production Level
    //
    // Apply the Production Level boost and Multiplier to the expected cargo output.
    // :param expected_value: Units of cargo to generate at base level.
    // :param multiplier: Extraction or Conversion Ratio to apply.
    // :return: Adjusted value.

    LOAD_PERM(87)
]) {
    0: return ((expected_value * multiplier * LOAD_PERM(88) * 44) / 1000);
    1: return ((expected_value * multiplier * LOAD_PERM(88) * 44) / 1000);
    2: return ((expected_value * multiplier * LOAD_PERM(88) * 66) / 1000);
    3: return ((expected_value * multiplier * LOAD_PERM(88) * 100) / 1000);
    4: return ((expected_value * multiplier * LOAD_PERM(88) * 150) / 1000);
    5: return ((expected_value * multiplier * LOAD_PERM(88) * 225) / 1000);
    6: return ((expected_value * multiplier * LOAD_PERM(88) * 338) / 1000);
    return expected_value;  // Fallback to expected value
}

// Update cargos received last season and recompute multipliers.
// ----------------------------------------------------------------
switch(FEAT_INDUSTRIES, SELF, update_extraction_ratio, [
    // PERM 090: Current Extraction Ratio
    // PERM 091: Current Conversion Ratio
    //
    // Recalculate and store the current Extraction and Conversion Ratios.
    // :return: 0, signifying no change.

    STORE_PERM(extraction_ratio(), 90),
    STORE_PERM(conversion_ratio(), 91)
]) {
    return 0;
}

switch(FEAT_INDUSTRIES, SELF, iterate_production_cycle_tick_cargo_helper, sum_index, sub_index, [
    // TEMP 032: Current sum
    // Tags: #helper
    // 
    // Update the current sum with value in the current permanent register.
    // :param sum_index: PERM Register marking the end of the array.
    // :param sub_index: PERM Register marking the array offset.
    
    STORE_TEMP(LOAD_TEMP(32) + load_perm_variable(sum_index-28+sub_index), 32)
]) {
    return;
}

switch(FEAT_INDUSTRIES, SELF, iterate_production_cycle_tick_cargo, sum_index, [
    // TEMP 032: Current sum
    // Tags: #iterator
    //
    // Calculate the sum of cargo delivered last season, and store it in the sum index.
    // :param sum_index: PERM Register containing this season's sum of cargo delivered.
    // :return: 0, signifying no change.

    STORE_TEMP(0, 32),      // Reset sum
    // Iterate through each index in the array
    iterate_production_cycle_tick_cargo_helper(sum_index, 1),
    iterate_production_cycle_tick_cargo_helper(sum_index, 2),
    iterate_production_cycle_tick_cargo_helper(sum_index, 3),
    iterate_production_cycle_tick_cargo_helper(sum_index, 4),
    iterate_production_cycle_tick_cargo_helper(sum_index, 5),
    iterate_production_cycle_tick_cargo_helper(sum_index, 6),
    iterate_production_cycle_tick_cargo_helper(sum_index, 7),
    iterate_production_cycle_tick_cargo_helper(sum_index, 8),
    iterate_production_cycle_tick_cargo_helper(sum_index, 9),
    iterate_production_cycle_tick_cargo_helper(sum_index, 10),
    iterate_production_cycle_tick_cargo_helper(sum_index, 11),
    iterate_production_cycle_tick_cargo_helper(sum_index, 12),
    iterate_production_cycle_tick_cargo_helper(sum_index, 13),
    iterate_production_cycle_tick_cargo_helper(sum_index, 14),
    iterate_production_cycle_tick_cargo_helper(sum_index, 15),
    iterate_production_cycle_tick_cargo_helper(sum_index, 16),
    iterate_production_cycle_tick_cargo_helper(sum_index, 17),
    iterate_production_cycle_tick_cargo_helper(sum_index, 18),
    iterate_production_cycle_tick_cargo_helper(sum_index, 19),
    iterate_production_cycle_tick_cargo_helper(sum_index, 20),
    iterate_production_cycle_tick_cargo_helper(sum_index, 21),
    iterate_production_cycle_tick_cargo_helper(sum_index, 22),
    iterate_production_cycle_tick_cargo_helper(sum_index, 23),
    iterate_production_cycle_tick_cargo_helper(sum_index, 24),
    iterate_production_cycle_tick_cargo_helper(sum_index, 25),
    iterate_production_cycle_tick_cargo_helper(sum_index, 26),
    iterate_production_cycle_tick_cargo_helper(sum_index, 27),
    STORE_PERM(LOAD_TEMP(32), sum_index),           // Store the calculated total in the sum_index
    STORE_PERM(0, sum_index-28+LOAD_PERM(0)+1),     // Store 0 in this production cycle index's register
    sum_index                                       // Switch on sum_index
]) {
    28: update_extraction_ratio();                  // If we just updated the first cargo, then update the extraction ratio.
    return 0;
}
 
switch(FEAT_INDUSTRIES, SELF, production_cycle_tick_helper, cargo_index, [
    // Tags: #helper
    // TEMP 127: PERM Register address containing the sum for the specified cargo.
    //
    // Update the sum of cargo delivered for the specified cargo.
    // :param cargo_index: Index of input cargo to summate. {0, 1, 2}
    // :return 0, signifying no change.

    STORE_TEMP(28*(1+cargo_index), 127),                        // Store index of sum register
]) {
    iterate_production_cycle_tick_cargo(LOAD_TEMP(127));        // Kick off summation
}

switch(FEAT_INDUSTRIES, SELF, production_cycle_tick, [
    // Tags: #iterator
    // PERM 000: Current cycle out of 27 in this season.
    //
    // Update the cycle in the season, and re-evaluate each cargo's total delivered sum.

    STORE_PERM((LOAD_PERM(0)+1)%27, 0),         // Load production cycle index, increment, and mod 27
    production_cycle_tick_helper(0),
    production_cycle_tick_helper(1),
    production_cycle_tick_helper(2)
]) {
    return;
}
// --------------------------------

// Accept incoming input cargoes.
// ----------------------------------------------------------------
switch(FEAT_INDUSTRIES, SELF, increment_accepted_cargo, cargo_index, cargo_quantity, [
    // Tags: #helper
    // PERM 000: Current day in this season
    // TEMP 064: Address of PERM Register containing the delivered cargo for the current cycle in this season
    //
    // Update the amount of cargo delivered this production cycle.
    // :param cargo_index: Index of input cargo being accepted. {0, 1, 2}
    // :param cargo_quantity: Amount of cargo being accepted.
    
    STORE_TEMP(1+28*cargo_index+LOAD_PERM(0), 64),                     // Get register representing production cycle
    STORE_PERM(load_perm_variable(LOAD_TEMP(64))+cargo_quantity, LOAD_TEMP(64))
]) {
    return;
}

switch(FEAT_INDUSTRIES, SELF, do_cargo_accept_cycle, cargo_quantity_0, cargo_quantity_1, cargo_quantity_2, [
    // Tags: #iterator
    //
    // Increment each accepted cargo, then calculate the total accepted this shipment.
    // :param cargo_quantity_0: Amount of input cargo 0 to accept.
    // :param cargo_quantity_1: Amount of input cargo 1 to accept.
    // :param cargo_quantity_2: Amount of input cargo 2 to accept.
    // :return: Total units of cargo accepted.

    increment_accepted_cargo(0, cargo_quantity_0),
    increment_accepted_cargo(1, cargo_quantity_1),
    increment_accepted_cargo(2, cargo_quantity_2)
]) {
    return cargo_quantity_0 + cargo_quantity_1 + cargo_quantity_2;
}
// --------------------------------

// Generate extra text for each industry.
// ----------------------------------------------------------------
switch(FEAT_INDUSTRIES, SELF, extra_text_industry_generic, [
    // Tags: #bitmath #textstack
    // PERM 085: Consecutive seasons of poor service.
    // PERM 086: Consecutive seasons of good service.
    // PERM 087: Current production level.
    // TEMP 256: Textstack.
    //
    // Add Production Level and consecutive seasons of good/poor service to textstack.
    // Then, return the appropriate industry text.
    // :return: String message to display.

                    // Store Production Level at bytes 0..1
    STORE_TEMP(     ((LOAD_PERM(87) == 0) * string(STR_INDUSTRY_POWER_MINIMUM)      ) +
                    ((LOAD_PERM(87) == 1) * string(STR_INDUSTRY_POWER_MINIMUM)      ) +
                    ((LOAD_PERM(87) == 2) * string(STR_INDUSTRY_POWER_LOW)          ) +
                    ((LOAD_PERM(87) == 3) * string(STR_INDUSTRY_POWER_DEFAULT)      ) +
                    ((LOAD_PERM(87) == 4) * string(STR_INDUSTRY_POWER_HIGH)         ) +
                    ((LOAD_PERM(87) == 5) * string(STR_INDUSTRY_POWER_VERY_HIGH)    ) +
                    ((LOAD_PERM(87) == 6) * string(STR_INDUSTRY_POWER_MAXIMUM)      ) |
                    // Store consecutive seasons at bytes 2..6
                    ((LOAD_PERM(85)+LOAD_PERM(86)) << 16),
                    256
                ),
    LOAD_PERM(85)
]) {
    0: return string(STR_INDUSTRY_LEVEL_STATE_GENERIC_GROWING);
    return string(STR_INDUSTRY_LEVEL_STATE_GENERIC_DECAYING);
}

switch(FEAT_INDUSTRIES, SELF, extra_text_industry_engineering, [
    // Tags: #bitmath #textstack
    // PERM 028: Total amount of input cargo 0 received last season.
    // PERM 085: Consecutive seasons of poor service.
    // PERM 085: Consecutive seasons of good service.
    // PERM 087: Current production level.
    // PERM 090: Extraction Ratio.
    // TEMP 256: Textstack.
    // TEMP 257: Textstack.
    // TEMP 258: Textstack.
    //
    // Add Production Level and consecutive seasons of good/poor service to textstack.
    // Also add Extraction Ratio from Engineering Supplies to textstack.
    // Then, return the appropriate industry text.
    // :return: String message to display.

                    // Store Production Level at bytes 0..1
    STORE_TEMP(     ((LOAD_PERM(87) == 0) * string(STR_INDUSTRY_POWER_MINIMUM)      ) +
                    ((LOAD_PERM(87) == 1) * string(STR_INDUSTRY_POWER_MINIMUM)      ) +
                    ((LOAD_PERM(87) == 2) * string(STR_INDUSTRY_POWER_LOW)          ) +
                    ((LOAD_PERM(87) == 3) * string(STR_INDUSTRY_POWER_DEFAULT)      ) +
                    ((LOAD_PERM(87) == 4) * string(STR_INDUSTRY_POWER_HIGH)         ) +
                    ((LOAD_PERM(87) == 5) * string(STR_INDUSTRY_POWER_VERY_HIGH)    ) +
                    ((LOAD_PERM(87) == 6) * string(STR_INDUSTRY_POWER_MAXIMUM)      ) |
                    // Store consecutive seasons at bytes 2..6
                    ((LOAD_PERM(85)+LOAD_PERM(86)) << 16),
                    256
                ),
                    // Store Extraction Ratio at bytes 7..8
    STORE_TEMP(     (((LOAD_PERM(90) == 1) * string(STR_INDUSTRY_RATIO_STATE_NORMAL)     ) +
                    ((LOAD_PERM(90) == 2) * string(STR_INDUSTRY_RATIO_STATE_ENHANCED)   ) +
                    ((LOAD_PERM(90) == 4) * string(STR_INDUSTRY_RATIO_STATE_GUNG_HO)    )) << 16,
                    257
                ),
                    // Store Engineering Supplies delivered last season at bytes 9..12
    STORE_TEMP(LOAD_PERM(28), 258),
    LOAD_PERM(85)
]) {
    0: return string(STR_INDUSTRY_LEVEL_STATE_ENGS_GROWING);
    return string(STR_INDUSTRY_LEVEL_STATE_ENGS_DECAYING);
}

switch(FEAT_INDUSTRIES, SELF, extra_text_industry_fertilizer, [
    // Tags: #bitmath #textstack
    // PERM 028: Total amount of input cargo 0 received last season.
    // PERM 085: Consecutive seasons of poor service.
    // PERM 085: Consecutive seasons of good service.
    // PERM 087: Current production level.
    // PERM 090: Extraction Ratio.
    // TEMP 256: Textstack.
    // TEMP 257: Textstack.
    // TEMP 258: Textstack.
    //
    // Add Production Level and consecutive seasons of good/poor service to textstack.
    // Also add Extraction Ratio from Fertilizer to textstack.
    // Then, return the appropriate industry text.
    // :return: String message to display.

                    // Store Production Level at bytes 0..1
    STORE_TEMP(     ((LOAD_PERM(87) == 0) * string(STR_INDUSTRY_POWER_MINIMUM)      ) +
                    ((LOAD_PERM(87) == 1) * string(STR_INDUSTRY_POWER_MINIMUM)      ) +
                    ((LOAD_PERM(87) == 2) * string(STR_INDUSTRY_POWER_LOW)          ) +
                    ((LOAD_PERM(87) == 3) * string(STR_INDUSTRY_POWER_DEFAULT)      ) +
                    ((LOAD_PERM(87) == 4) * string(STR_INDUSTRY_POWER_HIGH)         ) +
                    ((LOAD_PERM(87) == 5) * string(STR_INDUSTRY_POWER_VERY_HIGH)    ) +
                    ((LOAD_PERM(87) == 6) * string(STR_INDUSTRY_POWER_MAXIMUM)      ) |
                    // Store consecutive seasons at bytes 2..6
                    ((LOAD_PERM(85)+LOAD_PERM(86)) << 16),
                    256
                ),
                    // Store Extraction Ratio at bytes 7..8
    STORE_TEMP(     (((LOAD_PERM(90) == 1) * string(STR_INDUSTRY_RATIO_STATE_NORMAL)     ) +
                    ((LOAD_PERM(90) == 2) * string(STR_INDUSTRY_RATIO_STATE_ENHANCED)   ) +
                    ((LOAD_PERM(90) == 4) * string(STR_INDUSTRY_RATIO_STATE_GUNG_HO)    )) << 16,
                    257
                ),
                    // Store Fertilizer delivered last season at bytes 9..12
    STORE_TEMP(LOAD_PERM(28), 258),
    LOAD_PERM(85)
]) {
    0: return string(STR_INDUSTRY_LEVEL_STATE_FERT_GROWING);
    return string(STR_INDUSTRY_LEVEL_STATE_FERT_DECAYING);
}

switch(FEAT_INDUSTRIES, SELF, extra_text_industry_combo, [
    // Tags: #bitmath #textstack
    // PERM 085: Consecutive seasons of poor service.
    // PERM 085: Consecutive seasons of good service.
    // PERM 087: Current production level.
    // PERM 091: Conversion Ratio.
    // TEMP 256: Textstack.
    // TEMP 257: Textstack.
    //
    // Add Production Level and consecutive seasons of good/poor service to textstack.
    // Also add Conversion Ratio to textstack.
    // Then, return the appropriate industry text.
    // :return: String message to display.

                    // Store Production Level at bytes 0..1
    STORE_TEMP(     ((LOAD_PERM(87) == 0) * string(STR_INDUSTRY_POWER_MINIMUM)      ) +
                    ((LOAD_PERM(87) == 1) * string(STR_INDUSTRY_POWER_MINIMUM)      ) +
                    ((LOAD_PERM(87) == 2) * string(STR_INDUSTRY_POWER_LOW)          ) +
                    ((LOAD_PERM(87) == 3) * string(STR_INDUSTRY_POWER_DEFAULT)      ) +
                    ((LOAD_PERM(87) == 4) * string(STR_INDUSTRY_POWER_HIGH)         ) +
                    ((LOAD_PERM(87) == 5) * string(STR_INDUSTRY_POWER_VERY_HIGH)    ) +
                    ((LOAD_PERM(87) == 6) * string(STR_INDUSTRY_POWER_MAXIMUM)      ) |
                    // Store consecutive seasons at bytes 2..6
                    ((LOAD_PERM(85)+LOAD_PERM(86)) << 16),
                    256
                ),
                    // Store Conversion Ratio at bytes 7..8
    STORE_TEMP(     (((LOAD_PERM(91) == 1) * string(STR_INDUSTRY_RATIO_STATE_NORMAL)     ) +
                    ((LOAD_PERM(91) == 2) * string(STR_INDUSTRY_RATIO_STATE_ENHANCED)   ) +
                    ((LOAD_PERM(91) == 4) * string(STR_INDUSTRY_RATIO_STATE_GUNG_HO)    )) << 16,
                    257
                ),
    LOAD_PERM(85)
]) {
    0: return string(STR_INDUSTRY_LEVEL_STATE_COMBO_GROWING);
    return string(STR_INDUSTRY_LEVEL_STATE_COMBO_DECAYING);
}

switch(FEAT_INDUSTRIES, SELF, cargo_subtype_display_input, cargo_index, [
    // Tags: #helper
    //
    // Construct cargo subtype to display.
    // :param cargo_index: Input cargo index. {0, 1, 2}
    // :return: Empty string if no cargo delivered last season, supplied message otherwise.

    load_perm_variable(28*(1+cargo_index))
]) {
    // 0x3800 clears extra information from cargo subtype
    0: return (0x3800 + string(STR_EMPTY));
    return 0x3800 + string(STR_CARGO_SUPPLIED);
}

switch(FEAT_INDUSTRIES, SELF, cargo_subtype_display_industry, [
    // TEMP 064: Input cargo index. {0, 1, 2}
    //
    // Construct cargo subtype to display.
    // :return: Cargo subtype display, or no text.
    STORE_TEMP(getbits(extra_callback_info2, 0, 8), 64),
    LOAD_TEMP(64)
]) {
    0..2: return cargo_subtype_display_input(LOAD_TEMP(64));
    return CB_RESULT_IND_NO_TEXT_NO_AMOUNT;
}
// --------------------------------

// Randomization functions that seed using industry random bits first, then update using FEAT_INDUSTRYTILES.
// ----------------------------------------------------------------
random_switch(FEAT_INDUSTRIES, SELF, seed_d3) {
    // Tags: #random
    //
    // Initial seed before INDUSTRYTILES have updated and while this industry's random bits are unused.
    // :return: Random in (1..3)

    1: return 1;
    1: return 2;
    1: return 3;
}

switch(FEAT_INDUSTRIES, SELF, roll_d3, ((lsfr_byte_stream() + seed_d3()) % 3)) {
    // Tags: #random
    // PERM 096: Random bits updated every 256 ticks by INDUSTRYTILES triggers.
    //
    // Roll a d3 using random bits sourced from INDUSTRYTILES and this industry's initial random bits.
    // :return: Random in (1..3)

    0: return 1;
    1: return 2;
    2: return 3;
}

random_switch(FEAT_INDUSTRIES, SELF, seed_d4) {
    // Tags: #random
    //
    // Initial seed before INDUSTRYTILES have updated and while INDUSTRY random bits are unused.
    // :return: Random in (1..4)

    independent: seed_d3;
    1: return 1;
    1: return 2;
    1: return 3;
    1: return 4;
}

switch(FEAT_INDUSTRIES, SELF, roll_d4, ((lsfr_byte_stream() + seed_d4()) % 4)) {
    // Tags: #random
    // PERM 096: Random bits updated every 256 ticks by INDUSTRYTILES triggers.
    //
    // Roll a d4 using random bits sourced from INDUSTRYTILES and this industry's initial random bits.
    // :return: Random in (1..4)

    0: return 1;
    1: return 2;
    2: return 3;
    3: return 4;
}

random_switch(FEAT_INDUSTRIES, SELF, seed_d12) {
    // Tags: #random
    //
    // Initial seed before INDUSTRYTILES have updated and while INDUSTRY random bits are unused.
    // :return: Random in (1..12)

    independent: seed_d3;
    independent: seed_d4;
    1: return 1;
    1: return 2;
    1: return 3;
    1: return 4;
    1: return 5;
    1: return 6;
    1: return 7;
    1: return 8;
    1: return 9;
    1: return 10;
    1: return 11;
    1: return 12;
}

switch(FEAT_INDUSTRIES, SELF, roll_d12, ((lsfr_byte_stream() + seed_d12()) % 12)) {
    // Tags: #random
    // PERM 096: Random bits updated every 256 ticks by INDUSTRYTILES triggers.
    //
    // Roll a d12 using random bits sourced from INDUSTRYTILES and this industry's initial random bits.
    // :return: Random in (1..12)

    0: return 1;
    1: return 2;
    2: return 3;
    3: return 4;
    4: return 5;
    5: return 6;
    6: return 7;
    7: return 8;
    8: return 9;
    9: return 10;
    10: return 11;
    11: return 12;
}
// --------------------------------

// Update an industry's Production Level based on the consecutive seasons of poor/good service.
// ----------------------------------------------------------------
switch(FEAT_INDUSTRIES, SELF, halve_production, [
    // PERM 087: The current Production Level.
    // PERM 085: Consecutive seasons of poor service.
    //
    // Reduce production level and reset counter.
    // :return: 1, signifying that production has decreased.

    STORE_PERM(LOAD_PERM(87)-1, 87),
    STORE_PERM(0, 85)
]) {
    return 1;
}

switch(FEAT_INDUSTRIES, SELF, double_production, [
    // PERM 087: The current Production Level.
    // PERM 086: Consecutive seasons of good service.
    //
    // Reduce production level and reset counter.
    // :return: 2, signifying that production has increased.

    STORE_PERM(LOAD_PERM(87)+1, 87),
    STORE_PERM(0, 86)
]) {
    return 2;
}

switch(FEAT_INDUSTRIES, SELF, close_production, [
    // PERM 087: The current Production Level.
    //
    // Close the industry if allowed.
    // :return: 3 if close possible, signifying that production has decreased, else 0, signifying no change.

    (LOAD_PERM(87) == 1) * industry_decay * industry_close
]) {
    1: return 3;
    return 0;
}

switch(FEAT_INDUSTRIES, SELF, decay_production, [
    // PERM 087: The current Production Level.
    //
    // Reduce production level if allowed.
    // :return: 0 if no change, 1 if production decreased, 2 if production increased, 3 if industry closed.

    (industry_decay + (LOAD_PERM(87) > industry_starting_power))
]) {
    0: return 0;
    halve_production;
}

switch(FEAT_INDUSTRIES, SELF, grow_production, [
    // PERM 087: The current Production Level.
    //
    // Raise production level if allowed.
    // :return: 0 if no change, 1 if production decreased, 2 if production increased, 3 if industry closed.

    (industry_growth + (LOAD_PERM(87) < industry_starting_power))
]) {
    0: return 0;
    double_production;
}

switch(FEAT_INDUSTRIES, SELF, roll_ruin_1, modifier, [
    // Determine whether to reduce production when at Minimum.
    // :param modifier: Amount to increase odds by due to consecutive seasons.
    // :return: 0 if no change, 3 if industry closed.

    roll_d12() + modifier
]) {
    1..15: return 0;
    close_production;
}

switch(FEAT_INDUSTRIES, SELF, roll_ruin_2, modifier, [
    // Determine whether to reduce production when at Low.
    // :param modifier: Amount to increase odds by due to consecutive seasons.
    // :return: 0 if no change, 1 if production decreased.

    roll_d12() + modifier
]) {
    1..14: return 0;
    decay_production;
}

switch(FEAT_INDUSTRIES, SELF, roll_ruin_3, modifier, [
    // Determine whether to reduce production when at Default.
    // :param modifier: Amount to increase odds by due to consecutive seasons.
    // :return: 0 if no change, 1 if production decreased.

    roll_d12() + modifier
]) {
    1..11: return 0;
    decay_production;
}

switch(FEAT_INDUSTRIES, SELF, roll_ruin_4, modifier, [
    // Determine whether to reduce production when at High.
    // :param modifier: Amount to increase odds by due to consecutive seasons.
    // :return: 0 if no change, 1 if production decreased.

    roll_d12() + modifier
]) {
    1..8: return 0;
    decay_production;
}

switch(FEAT_INDUSTRIES, SELF, roll_ruin_5, modifier, [
    // Determine whether to reduce production when at Very High.
    // :param modifier: Amount to increase odds by due to consecutive seasons.
    // :return: 0 if no change, 1 if production decreased.

    roll_d12() + modifier
]) {
    1..4: return 0;
    decay_production;
}

switch(FEAT_INDUSTRIES, SELF, roll_ruin_6, modifier, [
    // Determine whether to reduce production when at Maximum.
    // :param modifier: Amount to increase odds by due to consecutive seasons.
    // :return: 0 if no change, 1 if production decreased.

    roll_d12() + modifier
]) {
    1..2: return 0;
    decay_production;
}

switch(FEAT_INDUSTRIES, SELF, roll_progress_1, modifier, [
    // Determine whether to raise production when at Minimum.
    // :param modifier: Amount to increase odds by due to consecutive seasons.
    // :return: 0 if no change, 1 if production increased.

    roll_d12() + modifier
]) {
    1..4: return 0;
    grow_production;
}

switch(FEAT_INDUSTRIES, SELF, roll_progress_2, modifier, [
    // Determine whether to raise production when at Low.
    // :param modifier: Amount to increase odds by due to consecutive seasons.
    // :return: 0 if no change, 1 if production increased.

    roll_d12() + modifier
]) {
    1..8: return 0;
    grow_production;
}

switch(FEAT_INDUSTRIES, SELF, roll_progress_3, modifier, [
    // Determine whether to raise production when at Default.
    // :param modifier: Amount to increase odds by due to consecutive seasons.
    // :return: 0 if no change, 1 if production increased.

    roll_d12() + modifier
]) {
    1..11: return 0;
    grow_production;
}

switch(FEAT_INDUSTRIES, SELF, roll_progress_4, modifier, [
    // Determine whether to raise production when at High.
    // :param modifier: Amount to increase odds by due to consecutive seasons.
    // :return: 0 if no change, 1 if production increased.

    roll_d12() + modifier
]) {
    1..14: return 0;
    grow_production;
}

switch(FEAT_INDUSTRIES, SELF, roll_progress_5, modifier, [
    // Determine whether to raise production when at Very High.
    // :param modifier: Amount to increase odds by due to consecutive seasons.
    // :return: 0 if no change, 1 if production increased.

    roll_d12() + modifier
]) {
    1..15: return 0;
    grow_production;
}

switch(FEAT_INDUSTRIES, SELF, do_seasonal_ruin_update, [
    // PERM 085: Consecutive seasons of poor service.
    // PERM 087: Current Production Level.
    // 
    // Randomly decrease production based on Production Level and conseuctive seasons.
    // :return: 0 if no change, 1 if production decreased, 2 if production increased, 3 if industry closed.

    LOAD_PERM(87)
]) {
    1: roll_ruin_1(LOAD_PERM(85)-1);
    2: roll_ruin_2(LOAD_PERM(85)-1);
    3: roll_ruin_3(LOAD_PERM(85)-1);
    4: roll_ruin_4(LOAD_PERM(85)-1);
    5: roll_ruin_5(LOAD_PERM(85)-1);
    6: roll_ruin_6(LOAD_PERM(85)-1);
    return 0;
}

switch(FEAT_INDUSTRIES, SELF, do_seasonal_progress_update, [
    // PERM 086: Consecutive seasons of good service.
    // PERM 087: Current Production Level.
    // 
    // Randomly increase production based on Production Level and conseuctive seasons.
    // :return: 0 if no change, 1 if production decreased, 2 if production increased.
    
    LOAD_PERM(87)
]) {
    1: roll_progress_1(LOAD_PERM(86)-1);
    2: roll_progress_2(LOAD_PERM(86)-1);
    3: roll_progress_3(LOAD_PERM(86)-1);
    4: roll_progress_4(LOAD_PERM(86)-1);
    5: roll_progress_5(LOAD_PERM(86)-1);
    return 0;
}

switch(FEAT_INDUSTRIES, SELF, reset_progress, [
    // PERM 085: Consecutive seasons of poor service.
    // PERM 086: Consecutive seasons of good service.
    //
    // Reset consecutive seasons of good and poor service.
    
    STORE_PERM(0, 86),
    STORE_PERM(0, 85)
]) {
    return;
}

switch(FEAT_INDUSTRIES, SELF, increment_ruin_helper, [
    // Tags: #helper
    // PERM 085: Consecutive seasons of poor service.
    // PERM 086: Consecutive seasons of good service.
    //
    // Increment seasons of poor service and reset good service.

    STORE_PERM(LOAD_PERM(85)+1, 85),
    STORE_PERM(0, 86)
]) {
    return;
}

switch(FEAT_INDUSTRIES, SELF, increment_ruin, [
    // PERM 097: Whether this industry has ever been serviced.
    //
    // If this industry has been serviced, proceed with updating ruin.
    // :return: 0, signifying no change.
    
    LOAD_PERM(97)
]) {
    1: increment_ruin_helper;
    return 0;
}

switch(FEAT_INDUSTRIES, SELF, increment_progress_helper, [
    // Tags: #helper
    // PERM 085: Consecutive seasons of poor service.
    // PERM 086: Consecutive seasons of good service.
    //
    // Increment seasons of good service and reset poor service.

    STORE_PERM(LOAD_PERM(86)+1, 86),
    STORE_PERM(0, 85)
]) {
    return;
}

switch(FEAT_INDUSTRIES, SELF, increment_progress, [
    // PERM 097: Whether this industry has ever been serviced.
    //
    // If this industry has been serviced, proceed with updating growth.
    // :return: 0, signifying no change.

    LOAD_PERM(97)
]) {
    1: increment_progress_helper;
    return 0;
}

switch(FEAT_INDUSTRIES, SELF, do_seasonal_activity_update, [
    // PERM 093: Highest average service two months ago.
    // PERM 094: Highest average service one month ago.
    // PERM 095: Highest average service this past month.
    //
    // Take the average of the past season of service,
    // and update consecutive service accordingly.

    ((LOAD_PERM(93) + LOAD_PERM(94) + LOAD_PERM(95)) / 3)
]) {
    0..39: increment_ruin;
    40..60: reset_progress;
    61..100: increment_progress;
}

switch(FEAT_INDUSTRIES, SELF, update_industry_helper, [
    // Tags: #helper
    // PERM 085: Consecutive seasons of poor service
    //
    // If service has been poor for multiple seasons, update ruin.
    // :return: 0 if no change, 1 if production decreased, 2 if production increased, 3 if industry closed.

    LOAD_PERM(85)
]) {
    0..1: return 0;
    do_seasonal_ruin_update;
}

switch(FEAT_INDUSTRIES, SELF, update_industry, [
    // PERM 086: Consecutive seasons of good service
    //
    // Update cargo received this season, then determine if industry should
    // grow, decay, or stay the same.
    // :return: 0 if no change, 1 if production decreased, 2 if production increased, 3 if industry closed.

    do_seasonal_activity_update(),
    LOAD_PERM(86)
]) {
    0: update_industry_helper;
    1: return 0;
    do_seasonal_progress_update;
}

switch(FEAT_INDUSTRIES, SELF, select_message, inc_msg_a, inc_msg_b, inc_msg_c, inc_msg_d, dec_msg_a, dec_msg_b, dec_msg_c, dec_msg_d, selection, text_no, [
    // Return a random industry message depending on if growth increased, changed, or stayed the same.
    // :param inc_msg_a: Increase message A.
    // :param inc_msg_b: Increase message B.
    // :param inc_msg_c: Increase message C.
    // :param inc_msg_d: Increase message D.
    // :param dec_msg_a: Decrease message A.
    // :param dec_msg_b: Decrease message B.
    // :param dec_msg_c: Decrease message C.
    // :param dec_msg_d: Decrease message D.
    // :param selection: Industry change. {0, 1, 2, 3}
    // :return: Callback message.

    STORE_TEMP(     ((selection == 1) * (text_no == 1) * dec_msg_a +
                    (selection == 1) * (text_no == 2) * dec_msg_b +
                    (selection == 1) * (text_no == 3) * dec_msg_c +
                    (selection == 1) * (text_no == 4) * dec_msg_d +
                    (selection == 2) * (text_no == 1) * inc_msg_a +
                    (selection == 2) * (text_no == 2) * inc_msg_b +
                    (selection == 2) * (text_no == 3) * inc_msg_c +
                    (selection == 2) * (text_no == 4) * inc_msg_d
            ), 256),
    selection
]) {
    0: return CB_RESULT_IND_PROD_NO_CHANGE;
    1..2: return CB_RESULT_IND_PROD_NO_CHANGE | bitmask(8);
    return CB_RESULT_IND_PROD_CLOSE;
}

switch(FEAT_INDUSTRIES, SELF, do_seasonal_prod_update, inc_msg_a, inc_msg_b, inc_msg_c, inc_msg_d, dec_msg_a, dec_msg_b, dec_msg_c, dec_msg_d, [
    // TEMP 123: Random number. {1, 2, 3, 4}
    // TEMP 124: How the industry has changed {0, 1, 2, 3}
    //
    // Update the industry's cargo and growth, then randomly return an appropriate callback message.
    // :param inc_msg_a: Increase message A.
    // :param inc_msg_b: Increase message B.
    // :param inc_msg_c: Increase message C.
    // :param inc_msg_d: Increase message D.
    // :param dec_msg_a: Decrease message A.
    // :param dec_msg_b: Decrease message B.
    // :param dec_msg_c: Decrease message C.
    // :param dec_msg_d: Decrease message D.
    // :return: Callback message.
    
    STORE_TEMP(update_industry(), 124),
    STORE_TEMP(roll_d4(), 123)
]) {
    select_message(inc_msg_a, inc_msg_b, inc_msg_c, inc_msg_d, dec_msg_a, dec_msg_b, dec_msg_c, dec_msg_d, LOAD_TEMP(124), LOAD_TEMP(123));
}

switch(FEAT_INDUSTRIES, SELF, check_seasonal_prod_update, inc_msg_a, inc_msg_b, inc_msg_c, inc_msg_d, dec_msg_a, dec_msg_b, dec_msg_c, dec_msg_d, best_service, [
    // PERM 089: Month of season {1, 2, 3}
    // PERM 097: Best average service this month.
    //
    // Randomly decide whether to update the industry's cargo and growth, 
    // then randomly return an appropriate callback message.
    // :param inc_msg_a: Increase message A.
    // :param inc_msg_b: Increase message B.
    // :param inc_msg_c: Increase message C.
    // :param inc_msg_d: Increase message D.
    // :param dec_msg_a: Decrease message A.
    // :param dec_msg_b: Decrease message B.
    // :param dec_msg_c: Decrease message C.
    // :param dec_msg_d: Decrease message D.
    // :return: Callback message.

    STORE_PERM((LOAD_PERM(89)+1)%3, 89),
    STORE_PERM(max((best_service != 0), LOAD_PERM(97)), 97),
    STORE_PERM(best_service, (93+LOAD_PERM(89))),
    // LOAD_PERM(89)   // every third season
    (roll_d3()-1)   // 33% of the time
]) {
    0: do_seasonal_prod_update(inc_msg_a, inc_msg_b, inc_msg_c, inc_msg_d, dec_msg_a, dec_msg_b, dec_msg_c, dec_msg_d, );
    return CB_RESULT_IND_PROD_NO_CHANGE; 
}
// --------------------------------

random_switch(FEAT_INDUSTRIES, SELF, randomize_production) {
    // Randomly set this industry's base production rate.
    // :return: Production rate over 10.

    independent: seed_d4;
    independent: seed_d12;
    independent: seed_d3;
    2: return 6;
    6: return 7;
    10: return 8;
    16: return 9;
    32: return 10;
    16: return 11;
    10: return 12;
    6: return 13;
    2: return 14;
}

switch(FEAT_INDUSTRIES, SELF, initialize_industry, [
    // PERM 087: Starting production level of this industry
    // PERM 088: Randomized production of this industry.
    //
    // Initialize industry production variables.
    // :return: 16 for arbitrary callback purposes.
    init_lsfr(),
    STORE_PERM(industry_starting_power, 87),
    STORE_PERM(randomize_production(), 88)
]) {
    return 16;
}

// ----------------------------------------------------------------
// Industry Items
// ----------------------------------------------------------------


// Port
// ----------------------------------------------------------------
// CLASS: PRIMARY
// MULTIPLIERS: PRODUCTION_LEVEL
// ACCEPTS:
// PRODUCES: 12 ENGS, 8 SALT ($2092/cycle)
// CONVERTS:

produce(produce_regular_port,
    [],
    [ENGS: LOAD_TEMP(6); SALT: LOAD_TEMP(7);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_port, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(12,1), 6),
    STORE_TEMP(apply_production_modifiers(8,1), 7)
]) {
    produce_regular_port;
}

item (FEAT_INDUSTRIES, industry_port) {
    property {
        substitute: 0x00;
        name: string(STR_INDUSTRY_NAME_PORT);
        nearby_station_name: string(STR_INDUSTRY_STATION_PORT);
        life_type: IND_LIFE_TYPE_EXTRACTIVE;
        cargo_types: [
            produce_cargo("ENGS", 0),
            produce_cargo("SALT", 0)
        ];
        spec_flags: bitmask();
        new_ind_msg: string(STR_INDUSTRY_PLANTED_PORT);
        closure_msg: string(STR_INDUSTRY_CLOSURE_PORT);
        prod_increase_msg: string(STR_INDUSTRY_PRODUCTION_INCREASE_PORT_A);
        prod_decrease_msg: string(STR_INDUSTRY_PRODUCTION_DECREASE_PORT_A);
        prob_in_game: 3;
        prob_map_gen: 4;
        fund_cost_multiplier: 150;
        prospect_chance: 0.75;
        map_colour: 146;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_coast_north,layout_coast_south,layout_coast_east,layout_coast_west];
    }
    graphics {
        location_check: is_isolated(16);
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_PORT_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_PORT_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_PORT_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_PORT_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_PORT_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_PORT_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_PORT_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_PORT_D), max(transported_last_month_pct("ENGS"),transported_last_month_pct("SALT")));
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        extra_text_industry: extra_text_industry_generic;
        build_prod_change: initialize_industry;
        produce_256_ticks: produce_256_ticks_port;
        cargo_subtype_display: cargo_subtype_display_industry;
    }
}
// --------------------------------

// Quarry
// ----------------------------------------------------------------
// CLASS: PRIMARY
// MULTIPLIERS: PRODUCTION_LEVEL, EXTRACTION_RATIO (ENGS)
// ACCEPTS: ENGS
// PRODUCES: 12 SAND, 8 PTSH ($2000/cycle)
// CONVERTS:

produce(produce_accept_quarry,
    [ENGS: LOAD_TEMP(0);],
    []
)

switch(FEAT_INDUSTRIES, SELF, produce_cargo_arrival_quarry, [
    STORE_TEMP(incoming_cargo_waiting("ENGS"), 0),
    STORE_TEMP(do_cargo_accept_cycle(incoming_cargo_waiting("ENGS"), 0, 0), 4)
]) {
    produce_accept_quarry;
}

produce(produce_regular_quarry, 
    [],
    [SAND: LOAD_TEMP(6); PTSH: LOAD_TEMP(7);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_quarry, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(12,LOAD_PERM(90)), 6),
    STORE_TEMP(apply_production_modifiers(8,LOAD_PERM(90)), 7)
]) {
    produce_regular_quarry;
}

item (FEAT_INDUSTRIES, industry_quarry) {
    property {
        substitute: 0x01;
        name: string(STR_INDUSTRY_NAME_QUARRY);
        nearby_station_name: string(STR_INDUSTRY_STATION_QUARRY);
        life_type: IND_LIFE_TYPE_EXTRACTIVE;
        cargo_types: [
            accept_cargo("ENGS"),
            produce_cargo("SAND", 0),
            produce_cargo("PTSH", 0)
        ];
        spec_flags: bitmask();
        new_ind_msg: string(STR_INDUSTRY_PLANTED_QUARRY);
        closure_msg: string(STR_INDUSTRY_CLOSURE_QUARRY);
        prod_increase_msg: string(STR_INDUSTRY_PRODUCTION_INCREASE_QUARRY_A);
        prod_decrease_msg: string(STR_INDUSTRY_PRODUCTION_DECREASE_QUARRY_A);
        prob_in_game: 8;
        prob_map_gen: 10;
        fund_cost_multiplier: 200;
        prospect_chance: 0.75;
        map_colour: 33;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_quarry];
    }
    graphics {
        location_check: is_isolated(16);
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_QUARRY_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_QUARRY_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_QUARRY_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_QUARRY_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_QUARRY_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_QUARRY_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_QUARRY_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_QUARRY_D), max(transported_last_month_pct("SAND"),transported_last_month_pct("PTSH")));
        build_prod_change: initialize_industry;
        produce_256_ticks: produce_256_ticks_quarry;
        produce_cargo_arrival: produce_cargo_arrival_quarry;
        extra_text_industry: extra_text_industry_engineering;
        cargo_subtype_display: cargo_subtype_display_industry;
    }
}
// --------------------------------

// Mineral Mine
// ----------------------------------------------------------------
// CLASS: PRIMARY
// MULTIPLIERS: PRODUCTION_LEVEL, EXTRACTION_RATIO (ENGS)
// ACCEPTS: ENGS
// PRODUCES: 16 MNRL ($1600/cycle)
// CONVERTS:

produce(produce_accept_mineral_mine,
    [ENGS: LOAD_TEMP(0);],
    []
)

switch(FEAT_INDUSTRIES, SELF, produce_cargo_arrival_mineral_mine, [
    STORE_TEMP(incoming_cargo_waiting("ENGS"), 0),
    STORE_TEMP(do_cargo_accept_cycle(incoming_cargo_waiting("ENGS"), 0, 0), 4)
]) {
    produce_accept_mineral_mine;
}

produce(produce_regular_mineral_mine,
    [],
    [MNRL: LOAD_TEMP(6);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_mineral_mine, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(16,LOAD_PERM(90)), 6),
]) {
    produce_regular_mineral_mine;
}

item (FEAT_INDUSTRIES, industry_mineral_mine) {
    property {
        substitute: 0x02;
        name: string(STR_INDUSTRY_NAME_MINERAL_MINE);
        nearby_station_name: string(STR_INDUSTRY_STATION_MINERAL_MINE);
        life_type: IND_LIFE_TYPE_EXTRACTIVE;
        cargo_types: [
            accept_cargo("ENGS"),
            produce_cargo("MNRL", 0),
        ];
        spec_flags: bitmask();
        new_ind_msg: string(STR_INDUSTRY_PLANTED_MINERAL_MINE);
        closure_msg: string(STR_INDUSTRY_CLOSURE_MINERAL_MINE);
        prod_increase_msg: string(STR_INDUSTRY_PRODUCTION_INCREASE_MINERAL_MINE_A);
        prod_decrease_msg: string(STR_INDUSTRY_PRODUCTION_DECREASE_MINERAL_MINE_A);
        prob_in_game: 4;
        prob_map_gen: 5;
        fund_cost_multiplier: 200;
        prospect_chance: 0.75;
        map_colour: 41;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_mineral_mine];
    }
    graphics {
        location_check: is_isolated(16);
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_MINERAL_MINE_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_MINERAL_MINE_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_MINERAL_MINE_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_MINERAL_MINE_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_MINERAL_MINE_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_MINERAL_MINE_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_MINERAL_MINE_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_MINERAL_MINE_D), transported_last_month_pct("MNRL"));
        build_prod_change: initialize_industry;
        produce_256_ticks: produce_256_ticks_mineral_mine;
        produce_cargo_arrival: produce_cargo_arrival_mineral_mine;
        extra_text_industry: extra_text_industry_engineering;
        cargo_subtype_display: cargo_subtype_display_industry;
    }
}
// --------------------------------

// Corn Farm
// ----------------------------------------------------------------
// CLASS: PRIMARY
// MULTIPLIERS: PRODUCTION_LEVEL, EXTRACTION_RATIO (FERT)
// ACCEPTS: FERT
// PRODUCES: 16 CORN ($1440/cycle)
// CONVERTS:

produce(produce_accept_corn_farm,
    [FERT: LOAD_TEMP(0);],
    []
)

switch(FEAT_INDUSTRIES, SELF, produce_cargo_arrival_corn_farm, [
    STORE_TEMP(incoming_cargo_waiting("FERT"), 0),
    STORE_TEMP(do_cargo_accept_cycle(incoming_cargo_waiting("FERT"), 0, 0), 4),
]) {
    produce_accept_corn_farm;
}

produce(produce_regular_corn_farm, 
    [],
    [CORN: LOAD_TEMP(6);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_corn_farm, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(16,LOAD_PERM(90)), 6)
]) {
    produce_regular_corn_farm;
}

item (FEAT_INDUSTRIES, industry_corn_farm) {
    property {
        substitute: 0x03;
        name: string(STR_INDUSTRY_NAME_CORN_FARM);
        nearby_station_name: string(STR_INDUSTRY_STATION_CORN_FARM);
        life_type: IND_LIFE_TYPE_ORGANIC;
        cargo_types: [
            accept_cargo("FERT"),
            produce_cargo("CORN", 0),
        ];
        spec_flags: bitmask(IND_FLAG_PLANT_FIELDS_PERIODICALLY, IND_FLAG_PLANT_FIELDS_WHEN_BUILT);
        new_ind_msg: string(STR_INDUSTRY_PLANTED_CORN_FARM);
        closure_msg: string(STR_INDUSTRY_CLOSURE_CORN_FARM);
        prod_increase_msg: string(STR_INDUSTRY_PRODUCTION_INCREASE_CORN_FARM_A);
        prod_decrease_msg: string(STR_INDUSTRY_PRODUCTION_DECREASE_CORN_FARM_A);
        prob_in_game: 8;
        prob_map_gen: 10;
        fund_cost_multiplier: 50;
        prospect_chance: 0.75;
        map_colour: 66;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_farm_vertical,layout_farm_horizontal];
    }
    graphics {
        location_check: is_isolated(16);
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_CORN_FARM_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_CORN_FARM_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_CORN_FARM_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_CORN_FARM_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_CORN_FARM_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_CORN_FARM_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_CORN_FARM_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_CORN_FARM_D), transported_last_month_pct("CORN"));
        build_prod_change: initialize_industry;
        produce_256_ticks: produce_256_ticks_corn_farm;
        produce_cargo_arrival: produce_cargo_arrival_corn_farm;
        extra_text_industry: extra_text_industry_fertilizer;
        cargo_subtype_display: cargo_subtype_display_industry;
    }
}
// --------------------------------

// Soy Farm
// ----------------------------------------------------------------
// CLASS: PRIMARY
// MULTIPLIERS: PRODUCTION_LEVEL, EXTRACTION_RATIO (FERT)
// ACCEPTS: FERT
// PRODUCES: 14 SOYB ($1540/cycle)
// CONVERTS:

produce(produce_accept_soy_farm,
    [FERT: LOAD_TEMP(0);],
    []
)

switch(FEAT_INDUSTRIES, SELF, produce_cargo_arrival_soy_farm, [
    STORE_TEMP(incoming_cargo_waiting("FERT"), 0),
    STORE_TEMP(do_cargo_accept_cycle(incoming_cargo_waiting("FERT"), 0, 0), 4),
]) {
    produce_accept_soy_farm;
}

produce(produce_regular_soy_farm, 
    [],
    [SOYB: LOAD_TEMP(6);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_soy_farm, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(14,LOAD_PERM(90)), 6)
]) {
    produce_regular_soy_farm;
}

item (FEAT_INDUSTRIES, industry_soy_farm) {
    property {
        substitute: 0x04;
        name: string(STR_INDUSTRY_NAME_SOY_FARM);
        nearby_station_name: string(STR_INDUSTRY_STATION_SOY_FARM);
        life_type: IND_LIFE_TYPE_ORGANIC;
        cargo_types: [
            accept_cargo("FERT"),
            produce_cargo("SOYB", 0),
        ];
        spec_flags: bitmask(IND_FLAG_PLANT_FIELDS_PERIODICALLY, IND_FLAG_PLANT_FIELDS_WHEN_BUILT);
        new_ind_msg: string(STR_INDUSTRY_PLANTED_SOY_FARM);
        closure_msg: string(STR_INDUSTRY_CLOSURE_SOY_FARM);
        prod_increase_msg: string(STR_INDUSTRY_PRODUCTION_INCREASE_SOY_FARM_A);
        prod_decrease_msg: string(STR_INDUSTRY_PRODUCTION_DECREASE_SOY_FARM_A);
        prob_in_game: 4;
        prob_map_gen: 5;
        fund_cost_multiplier: 50;
        prospect_chance: 0.75;
        map_colour: 71;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_farm_vertical,layout_farm_horizontal];
    }
    graphics {
        location_check: is_isolated(16);
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_SOY_FARM_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_SOY_FARM_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_SOY_FARM_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_SOY_FARM_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_SOY_FARM_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_SOY_FARM_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_SOY_FARM_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_SOY_FARM_D), transported_last_month_pct("SOYB"));
        build_prod_change: initialize_industry;
        produce_256_ticks: produce_256_ticks_soy_farm;
        produce_cargo_arrival: produce_cargo_arrival_soy_farm;
        extra_text_industry: extra_text_industry_fertilizer;
        cargo_subtype_display: cargo_subtype_display_industry;
    }
}
// --------------------------------

// Yam Farm
// ----------------------------------------------------------------
// CLASS: PRIMARY
// MULTIPLIERS: PRODUCTION_LEVEL, EXTRACTION_RATIO (FERT)
// ACCEPTS: FERT
// PRODUCES: 14 YAMS ($1540/cycle)
// CONVERTS:

produce(produce_accept_yam_farm,
    [FERT: LOAD_TEMP(0);],
    []
)

switch(FEAT_INDUSTRIES, SELF, produce_cargo_arrival_yam_farm, [
    STORE_TEMP(incoming_cargo_waiting("FERT"), 0),
    STORE_TEMP(do_cargo_accept_cycle(incoming_cargo_waiting("FERT"), 0, 0), 4),
]) {
    produce_accept_yam_farm;
}

produce(produce_regular_yam_farm, 
    [],
    [YAMS: LOAD_TEMP(6);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_yam_farm, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(14,LOAD_PERM(90)), 6)
]) {
    produce_regular_yam_farm;
}

item (FEAT_INDUSTRIES, industry_yam_farm) {
    property {
        substitute: 0x05;
        name: string(STR_INDUSTRY_NAME_YAM_FARM);
        nearby_station_name: string(STR_INDUSTRY_STATION_YAM_FARM);
        life_type: IND_LIFE_TYPE_ORGANIC;
        cargo_types: [
            accept_cargo("FERT"),
            produce_cargo("YAMS", 0),
        ];
        spec_flags: bitmask(IND_FLAG_PLANT_FIELDS_PERIODICALLY, IND_FLAG_PLANT_FIELDS_WHEN_BUILT);
        new_ind_msg: string(STR_INDUSTRY_PLANTED_YAM_FARM);
        closure_msg: string(STR_INDUSTRY_CLOSURE_YAM_FARM);
        prod_increase_msg: string(STR_INDUSTRY_PRODUCTION_INCREASE_YAM_FARM_A);
        prod_decrease_msg: string(STR_INDUSTRY_PRODUCTION_DECREASE_YAM_FARM_A);
        prob_in_game: 4;
        prob_map_gen: 5;
        fund_cost_multiplier: 50;
        prospect_chance: 0.75;
        map_colour: 75;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_farm_vertical,layout_farm_horizontal];
    }
    graphics {
        location_check: is_isolated(16);
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_YAM_FARM_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_YAM_FARM_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_YAM_FARM_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_YAM_FARM_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_YAM_FARM_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_YAM_FARM_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_YAM_FARM_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_YAM_FARM_D), transported_last_month_pct("YAMS"));
        build_prod_change: initialize_industry;
        produce_256_ticks: produce_256_ticks_yam_farm;
        produce_cargo_arrival: produce_cargo_arrival_yam_farm;
        extra_text_industry: extra_text_industry_fertilizer;
        cargo_subtype_display: cargo_subtype_display_industry;
    }
}
// --------------------------------

// Glassworks
// ----------------------------------------------------------------
// CLASS: SECONDARY
// MULTIPLIERS: PRODUCTION_LEVEL
// ACCEPTS: SAND
// PRODUCES: 9 VIAL, 9 GOOD                 ($2106/cycle)
// CONVERTS: 16 SAND -> 4 VIAL + 4 GOOD     ($58.50/unit of input)

produce(produce_accept_glassworks,
    [SAND: LOAD_TEMP(0);],
    [VIAL: LOAD_TEMP(4) * 4 / 16; GOOD: LOAD_TEMP(4) * 4 / 16;]
)

switch(FEAT_INDUSTRIES, SELF, produce_cargo_arrival_glassworks, [
    STORE_TEMP(incoming_cargo_waiting("SAND"), 0),
    STORE_TEMP(do_cargo_accept_cycle(incoming_cargo_waiting("SAND"), 0, 0), 4),
]) {
    produce_accept_glassworks;
}

produce(produce_regular_glassworks, 
    [],
    [VIAL: LOAD_TEMP(6); GOOD: LOAD_TEMP(7);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_glassworks, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(9, 1), 6),
    STORE_TEMP(apply_production_modifiers(9, 1), 7)
]) {
    produce_regular_glassworks;
}

item (FEAT_INDUSTRIES, industry_glassworks) {
    property {
        substitute: 0x06;
        name: string(STR_INDUSTRY_NAME_GLASSWORKS);
        nearby_station_name: string(STR_INDUSTRY_STATION_GLASSWORKS);
        life_type: IND_LIFE_TYPE_PROCESSING;
        cargo_types: [
            accept_cargo("SAND"),
            produce_cargo("VIAL", 0),
            produce_cargo("GOOD", 0),
        ];
        spec_flags: bitmask();
        new_ind_msg: string(STR_INDUSTRY_PLANTED_GLASSWORKS);
        closure_msg: string(STR_INDUSTRY_CLOSURE_GLASSWORKS);
        prod_increase_msg: string(STR_INDUSTRY_PRODUCTION_INCREASE_GLASSWORKS_A);
        prod_decrease_msg: string(STR_INDUSTRY_PRODUCTION_DECREASE_GLASSWORKS_A);
        prob_in_game: 8;
        prob_map_gen: 10;
        fund_cost_multiplier: 100;
        map_colour: 135;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_glassworks];
    }
    graphics {
        location_check: is_isolated(16);
        build_prod_change: initialize_industry;
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_GLASSWORKS_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_GLASSWORKS_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_GLASSWORKS_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_GLASSWORKS_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_GLASSWORKS_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_GLASSWORKS_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_GLASSWORKS_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_GLASSWORKS_D), transported_last_month_pct("VIAL"));
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        produce_256_ticks: produce_256_ticks_glassworks;
        produce_cargo_arrival: produce_cargo_arrival_glassworks;
        cargo_subtype_display: cargo_subtype_display_industry;
        extra_text_industry: extra_text_industry_generic;
    }
}
// --------------------------------

// Chemical Plant
// ----------------------------------------------------------------
// CLASS: SECONDARY
// MULTIPLIERS: PRODUCTION_LEVEL, CONVERSION RATIO
// ACCEPTS: SALT, PTSH, MNRL
// PRODUCES: 7 FERT, 5 CHEM                                                 ($2047/cycle)
// CONVERTS: 16 (SALT + PTSH + MNRL) -> {3, 6, 12} FERT + {2, 4, 8} CHEM   ({$53.06, $106.13, $212.26}/unit of input)

produce(produce_accept_chemical_plant,
    [SALT: LOAD_TEMP(0); PTSH: LOAD_TEMP(1); MNRL: LOAD_TEMP(2);],
    [FERT: LOAD_TEMP(4) * LOAD_PERM(91) * 3 / 16; CHEM: LOAD_TEMP(4) * LOAD_PERM(91) * 2 / 16;]
)

switch(FEAT_INDUSTRIES, SELF, produce_cargo_arrival_chemical_plant, [
    STORE_TEMP(incoming_cargo_waiting("SALT"), 0),
    STORE_TEMP(incoming_cargo_waiting("PTSH"), 1),
    STORE_TEMP(incoming_cargo_waiting("MNRL"), 2),
    STORE_TEMP(do_cargo_accept_cycle(incoming_cargo_waiting("SALT"), incoming_cargo_waiting("PTSH"), incoming_cargo_waiting("MNRL")), 4),
]) {
    produce_accept_chemical_plant;
}

produce(produce_regular_chemical_plant, 
    [], 
    [FERT: LOAD_TEMP(6); CHEM: LOAD_TEMP(7);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_chemical_plant, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(7, 1), 6),
    STORE_TEMP(apply_production_modifiers(5, 1), 7)
]) {
    produce_regular_chemical_plant;
}

item (FEAT_INDUSTRIES, industry_chemical_plant) {
    property {
        substitute: 0x07;
        name: string(STR_INDUSTRY_NAME_CHEMICAL_PLANT);
        nearby_station_name: string(STR_INDUSTRY_STATION_CHEMICAL_PLANT);
        life_type: IND_LIFE_TYPE_PROCESSING;
        cargo_types: [
            accept_cargo("SALT"),
            accept_cargo("PTSH"),
            accept_cargo("MNRL"),
            produce_cargo("FERT", 0),
            produce_cargo("CHEM", 0)
        ];
        spec_flags: bitmask();
        new_ind_msg: string(STR_INDUSTRY_PLANTED_CHEMICAL_PLANT);
        closure_msg: string(STR_INDUSTRY_CLOSURE_CHEMICAL_PLANT);
        prod_increase_msg: string(STR_INDUSTRY_PRODUCTION_INCREASE_CHEMICAL_PLANT_A);
        prod_decrease_msg: string(STR_INDUSTRY_PRODUCTION_DECREASE_CHEMICAL_PLANT_A);
        prob_in_game: 6;
        prob_map_gen: 9;
        fund_cost_multiplier: 100;
        map_colour: 185;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_chemical_plant];
    }
    graphics {
        location_check: is_isolated(16);
        build_prod_change: initialize_industry;
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_CHEMICAL_PLANT_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_CHEMICAL_PLANT_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_CHEMICAL_PLANT_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_CHEMICAL_PLANT_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_CHEMICAL_PLANT_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_CHEMICAL_PLANT_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_CHEMICAL_PLANT_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_CHEMICAL_PLANT_D), max(transported_last_month_pct("FERT"),transported_last_month_pct("CHEM")));
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        produce_256_ticks: produce_256_ticks_chemical_plant;
        produce_cargo_arrival: produce_cargo_arrival_chemical_plant;
        extra_text_industry: extra_text_industry_combo;
        cargo_subtype_display: cargo_subtype_display_industry;
    }
}
// --------------------------------

// Processing Plant
// ----------------------------------------------------------------
// CLASS: SECONDARY
// MULTIPLIERS: PRODUCTION_LEVEL
// ACCEPTS: CORN
// PRODUCES: 14 VGOL             ($1540/cycle)
// CONVERTS: 16 CORN -> 8 VGOL  ($55/unit of input)

produce(produce_accept_processing_plant,
    [CORN: LOAD_TEMP(0);],
    [VGOL: LOAD_TEMP(4) * 8 / 16;]
)

switch(FEAT_INDUSTRIES, SELF, produce_cargo_arrival_processing_plant, [
    STORE_TEMP(incoming_cargo_waiting("CORN"), 0),
    STORE_TEMP(do_cargo_accept_cycle(incoming_cargo_waiting("CORN"), 0, 0), 4),
]) {
    produce_accept_processing_plant;
}

produce(produce_regular_processing_plant, 
    [], 
    [VGOL: LOAD_TEMP(6);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_processing_plant, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(14, 1), 6)
]) {
    produce_regular_processing_plant;
}

item (FEAT_INDUSTRIES, industry_processing_plant) {
    property {
        substitute: 0x08;
        name: string(STR_INDUSTRY_NAME_PROCESSING_PLANT);
        nearby_station_name: string(STR_INDUSTRY_STATION_PROCESSING_PLANT);
        life_type: IND_LIFE_TYPE_PROCESSING;
        cargo_types: [
            accept_cargo("CORN"),
            produce_cargo("VGOL", 0),
        ];
        spec_flags: bitmask();
        new_ind_msg: string(STR_INDUSTRY_PLANTED_PROCESSING_PLANT);
        closure_msg: string(STR_INDUSTRY_CLOSURE_PROCESSING_PLANT);
        prod_increase_msg: string(STR_INDUSTRY_PRODUCTION_INCREASE_PROCESSING_PLANT_A);
        prod_decrease_msg: string(STR_INDUSTRY_PRODUCTION_DECREASE_PROCESSING_PLANT_A);
        prob_in_game: 8;
        prob_map_gen: 10;
        fund_cost_multiplier: 100;
        map_colour: 206;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_processing_plant];
    }
    graphics {
        location_check: is_isolated(16);
        build_prod_change: initialize_industry;
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_PROCESSING_PLANT_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_PROCESSING_PLANT_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_PROCESSING_PLANT_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_PROCESSING_PLANT_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_PROCESSING_PLANT_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_PROCESSING_PLANT_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_PROCESSING_PLANT_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_PROCESSING_PLANT_D), transported_last_month_pct("VGOL"));
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        produce_256_ticks: produce_256_ticks_processing_plant;
        produce_cargo_arrival: produce_cargo_arrival_processing_plant;
        cargo_subtype_display: cargo_subtype_display_industry;
        extra_text_industry: extra_text_industry_generic;
    }
}
// --------------------------------

// Distillery
// ----------------------------------------------------------------
// CLASS: SECONDARY
// MULTIPLIERS: PRODUCTION_LEVEL
// ACCEPTS: CORN
// PRODUCES: 14 ALCH             ($1540/cycle)
// CONVERTS: 16 CORN -> 8 ALCH  ($55/unit of input)

produce(produce_accept_distillery,
    [CORN: LOAD_TEMP(0);],
    [ALCH: LOAD_TEMP(4) * 8 / 16;]
)

switch(FEAT_INDUSTRIES, SELF, produce_cargo_arrival_distillery, [
    STORE_TEMP(incoming_cargo_waiting("CORN"), 0),
    STORE_TEMP(do_cargo_accept_cycle(incoming_cargo_waiting("CORN"), 0, 0), 4),
]) {
    produce_accept_distillery;
}

produce(produce_regular_distillery, 
    [], 
    [ALCH: LOAD_TEMP(6);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_distillery, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(14, 1), 6),
]) {
    produce_regular_distillery;
}

item (FEAT_INDUSTRIES, industry_distillery) {
    property {
        substitute: 0x09;
        name: string(STR_INDUSTRY_NAME_DISTILLERY);
        nearby_station_name: string(STR_INDUSTRY_STATION_DISTILLERY);
        life_type: IND_LIFE_TYPE_PROCESSING;
        cargo_types: [
            accept_cargo("CORN"),
            produce_cargo("ALCH", 0),
        ];
        spec_flags: bitmask();
        new_ind_msg: string(STR_INDUSTRY_PLANTED_DISTILLERY);
        closure_msg: string(STR_INDUSTRY_CLOSURE_DISTILLERY);
        prod_increase_msg: string(STR_INDUSTRY_PRODUCTION_INCREASE_DISTILLERY_A);
        prod_decrease_msg: string(STR_INDUSTRY_PRODUCTION_DECREASE_DISTILLERY_A);
        prob_in_game: 8;
        prob_map_gen: 10;
        fund_cost_multiplier: 100;
        map_colour: 192;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_distillery];
    }
    graphics {
        location_check: is_isolated(16);
        build_prod_change: initialize_industry;
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_DISTILLERY_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_DISTILLERY_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_DISTILLERY_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_DISTILLERY_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_DISTILLERY_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_DISTILLERY_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_DISTILLERY_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_DISTILLERY_D), transported_last_month_pct("ALCH"));
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        produce_256_ticks: produce_256_ticks_distillery;
        produce_cargo_arrival: produce_cargo_arrival_distillery;
        cargo_subtype_display: cargo_subtype_display_industry;
        extra_text_industry: extra_text_industry_generic;
    }
}
// --------------------------------

// Biolab
// ----------------------------------------------------------------
// CLASS: SECONDARY
// MULTIPLIERS: PRODUCTION_LEVEL, CONVERSION RATIO
// ACCEPTS: SOYB, YAMS, ALCH
// PRODUCES: 4 DIOS                                     ($1440/cycle)
// CONVERTS: 16 (SOYB + YAMS + ALCH) -> {2, 4, 8} DIOS  ({$45, $90, $180}/unit of inptu)

produce(produce_accept_biolab,
    [SOYB: LOAD_TEMP(0); YAMS: LOAD_TEMP(1); ALCH: LOAD_TEMP(2);],
    [DIOS: LOAD_TEMP(4) * LOAD_PERM(91) * 2 / 16;]
)

switch(FEAT_INDUSTRIES, SELF, produce_cargo_arrival_biolab, [
    STORE_TEMP(incoming_cargo_waiting("SOYB"), 0),
    STORE_TEMP(incoming_cargo_waiting("YAMS"), 1),
    STORE_TEMP(incoming_cargo_waiting("ALCH"), 2),
    STORE_TEMP(do_cargo_accept_cycle(incoming_cargo_waiting("SOYB"), incoming_cargo_waiting("YAMS"), incoming_cargo_waiting("ALCH")), 4),
]) {
    produce_accept_biolab;
}

produce(produce_regular_biolab, 
    [], 
    [DIOS: LOAD_TEMP(6);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_biolab, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(4, 1), 6)
]) {
    produce_regular_biolab;
}

item (FEAT_INDUSTRIES, industry_biolab) {
    property {
        substitute: 0x0A;
        name: string(STR_INDUSTRY_NAME_BIOLAB);
        nearby_station_name: string(STR_INDUSTRY_STATION_BIOLAB);
        life_type: IND_LIFE_TYPE_PROCESSING;
        cargo_types: [
            accept_cargo("SOYB"),
            accept_cargo("YAMS"),
            accept_cargo("ALCH"),
            produce_cargo("DIOS", 0),
        ];
        spec_flags: bitmask();
        new_ind_msg: string(STR_INDUSTRY_PLANTED_BIOLAB);
        closure_msg: string(STR_INDUSTRY_CLOSURE_BIOLAB);
        prod_increase_msg: string(STR_INDUSTRY_PRODUCTION_INCREASE_BIOLAB_A);
        prod_decrease_msg: string(STR_INDUSTRY_PRODUCTION_DECREASE_BIOLAB_A);
        prob_in_game: 6;
        prob_map_gen: 9;
        fund_cost_multiplier: 100;
        map_colour: 174;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_biolab];
    }
    graphics {
        location_check: is_isolated(16);
        build_prod_change: initialize_industry;
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_BIOLAB_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_BIOLAB_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_BIOLAB_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_BIOLAB_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_BIOLAB_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_BIOLAB_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_BIOLAB_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_BIOLAB_D), transported_last_month_pct("DIOS"));
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        produce_256_ticks: produce_256_ticks_biolab;
        produce_cargo_arrival: produce_cargo_arrival_biolab;
        extra_text_industry: extra_text_industry_combo;
        cargo_subtype_display: cargo_subtype_display_industry;
    }
}
// --------------------------------

// Pharmaceutical Plant (Estrogen)
// ----------------------------------------------------------------
// CLASS: SECONDARY
// MULTIPLIERS: PRODUCTION_LEVEL, CONVERSION RATIO
// ACCEPTS: DIOS, CHEM
// PRODUCES: 8 RWES                             ($1440/cycle)
// CONVERTS: 16 (DIOS + CHEM) -> {4, 8} RWES    ({$45, $90}/unit of input)

produce(produce_accept_pharmaceutical_plant_e,
    [DIOS: LOAD_TEMP(0); CHEM: LOAD_TEMP(1);],
    [RWES: LOAD_TEMP(4) * LOAD_PERM(91) * 4 / 16;]
)

switch(FEAT_INDUSTRIES, SELF, produce_cargo_arrival_pharmaceutical_plant_e, [
    STORE_TEMP(incoming_cargo_waiting("DIOS"), 0),
    STORE_TEMP(incoming_cargo_waiting("CHEM"), 1),
    STORE_TEMP(do_cargo_accept_cycle(incoming_cargo_waiting("DIOS"), incoming_cargo_waiting("CHEM"), 0), 4),
]) {
    produce_accept_pharmaceutical_plant_e;
}

produce(produce_regular_pharmaceutical_plant_e, 
    [], 
    [RWES: LOAD_TEMP(6);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_pharmaceutical_plant_e, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(8, 1), 6)
]) {
    produce_regular_pharmaceutical_plant_e;
}

item (FEAT_INDUSTRIES, industry_pharmaceutical_plant_e) {
    property {
        substitute: 0x0B;
        name: string(STR_INDUSTRY_NAME_PHARMACEUTICAL_PLANT_E);
        nearby_station_name: string(STR_INDUSTRY_STATION_PHARMACEUTICAL_PLANT_E);
        life_type: IND_LIFE_TYPE_PROCESSING;
        cargo_types: [
            accept_cargo("DIOS"),
            accept_cargo("CHEM"),
            produce_cargo("RWES", 0),
        ];
        spec_flags: bitmask();
        new_ind_msg: string(STR_INDUSTRY_PLANTED_PHARMACEUTICAL_PLANT_E);
        closure_msg: string(STR_INDUSTRY_CLOSURE_PHARMACEUTICAL_PLANT_E);
        prod_increase_msg: string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACEUTICAL_PLANT_E_A);
        prod_decrease_msg: string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACEUTICAL_PLANT_E_A);
        prob_in_game: 8;
        prob_map_gen: 10;
        fund_cost_multiplier: 100;
        map_colour: 152;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_pharmaceutical_plant];
    }
    graphics {
        location_check: is_isolated(16);
        build_prod_change: initialize_industry;
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACEUTICAL_PLANT_E_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACEUTICAL_PLANT_E_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACEUTICAL_PLANT_E_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACEUTICAL_PLANT_E_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACEUTICAL_PLANT_E_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACEUTICAL_PLANT_E_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACEUTICAL_PLANT_E_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACEUTICAL_PLANT_E_D), transported_last_month_pct("RWES"));
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        produce_256_ticks: produce_256_ticks_pharmaceutical_plant_e;
        produce_cargo_arrival: produce_cargo_arrival_pharmaceutical_plant_e;
        construction_probability: availability_in_estrogen;
        extra_text_industry: extra_text_industry_combo;
        cargo_subtype_display: cargo_subtype_display_industry;
    }
}
// --------------------------------

// Pharmaceutical Plant (Testosterone)
// ----------------------------------------------------------------
// CLASS: SECONDARY
// MULTIPLIERS: PRODUCTION_LEVEL, CONVERSION RATIO
// ACCEPTS: DIOS, CHEM
// PRODUCES: 8 RWTS                             ($1440/cycle)
// CONVERTS: 16 (DIOS + CHEM) -> {4, 8} RWTS    ({$45, $90}/unit of input)

produce(produce_accept_pharmaceutical_plant_t,
    [DIOS: LOAD_TEMP(0); CHEM: LOAD_TEMP(1);],
    [RWTS: LOAD_TEMP(4) * LOAD_PERM(91) * 4 / 16;]
)

switch(FEAT_INDUSTRIES, SELF, produce_cargo_arrival_pharmaceutical_plant_t, [
    STORE_TEMP(incoming_cargo_waiting("DIOS"), 0),
    STORE_TEMP(incoming_cargo_waiting("CHEM"), 1),
    STORE_TEMP(do_cargo_accept_cycle(incoming_cargo_waiting("DIOS"), incoming_cargo_waiting("CHEM"), 0), 4),
]) {
    produce_accept_pharmaceutical_plant_t;
}

produce(produce_regular_pharmaceutical_plant_t, 
    [], 
    [RWTS: LOAD_TEMP(6);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_pharmaceutical_plant_t, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(8, 1), 6)
]) {
    produce_regular_pharmaceutical_plant_t;
}

item (FEAT_INDUSTRIES, industry_pharmaceutical_plant_t) {
    property {
        substitute: 0x0C;
        name: string(STR_INDUSTRY_NAME_PHARMACEUTICAL_PLANT_T);
        nearby_station_name: string(STR_INDUSTRY_STATION_PHARMACEUTICAL_PLANT_T);
        life_type: IND_LIFE_TYPE_PROCESSING;
        cargo_types: [
            accept_cargo("DIOS"),
            accept_cargo("CHEM"),
            produce_cargo("RWTS", 0),
        ];
        spec_flags: bitmask();
        new_ind_msg: string(STR_INDUSTRY_PLANTED_PHARMACEUTICAL_PLANT_T);
        closure_msg: string(STR_INDUSTRY_CLOSURE_PHARMACEUTICAL_PLANT_T);
        prod_increase_msg: string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACEUTICAL_PLANT_T_A);
        prod_decrease_msg: string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACEUTICAL_PLANT_T_A);
        prob_in_game: 8;
        prob_map_gen: 10;
        fund_cost_multiplier: 100;
        map_colour: 103;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_pharmaceutical_plant];
    }
    graphics {
        location_check: is_isolated(16);
        build_prod_change: initialize_industry;
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACEUTICAL_PLANT_T_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACEUTICAL_PLANT_T_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACEUTICAL_PLANT_T_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACEUTICAL_PLANT_T_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACEUTICAL_PLANT_T_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACEUTICAL_PLANT_T_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACEUTICAL_PLANT_T_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACEUTICAL_PLANT_T_D), transported_last_month_pct("RWTS"));
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        produce_256_ticks: produce_256_ticks_pharmaceutical_plant_t;
        produce_cargo_arrival: produce_cargo_arrival_pharmaceutical_plant_t;
        construction_probability: availability_in_testosterone;
        extra_text_industry: extra_text_industry_combo;
        cargo_subtype_display: cargo_subtype_display_industry;
    }
}
// --------------------------------

// Pharmacy (Estrogen)
// ----------------------------------------------------------------
// CLASS: SECONDARY
// MULTIPLIERS: PRODUCTION_LEVEL, CONVERSION RATIO
// ACCEPTS: VIAL, VGOL, RWES
// PRODUCES: 4 ESTR                                     ($1520/cycle)
// CONVERTS: 16 (VIAL + VGOL + RWES) -> {2, 4, 8} ESTR  ({$47.50, $95, $190}/unit of input)

produce(produce_accept_pharmacy_e,
    [VIAL: LOAD_TEMP(0); VGOL: LOAD_TEMP(1); RWES: LOAD_TEMP(2);],
    [ESTR: LOAD_TEMP(4) * LOAD_PERM(91) * 2 / 16;]
)

switch(FEAT_INDUSTRIES, SELF, produce_cargo_arrival_pharmacy_e, [
    STORE_TEMP(incoming_cargo_waiting("VIAL"), 0),
    STORE_TEMP(incoming_cargo_waiting("VGOL"), 1),
    STORE_TEMP(incoming_cargo_waiting("RWES"), 2),
    STORE_TEMP(do_cargo_accept_cycle(incoming_cargo_waiting("VIAL"), incoming_cargo_waiting("VGOL"), incoming_cargo_waiting("RWES")), 4),
]) {
    produce_accept_pharmacy_e;
}

produce(produce_regular_pharmacy_e, 
    [], 
    [ESTR: LOAD_TEMP(6);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_pharmacy_e, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(4, 1), 6)
]) {
    produce_regular_pharmacy_e;
}

item (FEAT_INDUSTRIES, industry_pharmacy_e) {
    property {
        substitute: 0x0D;
        name: string(STR_INDUSTRY_NAME_PHARMACY_E);
        nearby_station_name: string(STR_INDUSTRY_STATION_PHARMACY_E);
        life_type: IND_LIFE_TYPE_PROCESSING;
        cargo_types: [
            accept_cargo("VIAL"),
            accept_cargo("VGOL"),
            accept_cargo("RWES"),
            produce_cargo("ESTR", 0)
        ];
        spec_flags: bitmask(IND_FLAG_BUILT_NEAR_TOWN);
        new_ind_msg: string(STR_INDUSTRY_PLANTED_PHARMACY_E);
        closure_msg: string(STR_INDUSTRY_CLOSURE_PHARMACY_E);
        prob_in_game: 6;
        prob_map_gen: 9;
        fund_cost_multiplier: 100;
        map_colour: 150;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_pharmacy];
    }
    graphics {
        location_check: is_isolated(16);
        build_prod_change: initialize_industry;
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACY_E_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACY_E_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACY_E_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACY_E_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACY_E_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACY_E_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACY_E_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACY_E_D), transported_last_month_pct("ESTR"));
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        produce_256_ticks: produce_256_ticks_pharmacy_e;
        produce_cargo_arrival: produce_cargo_arrival_pharmacy_e;
        construction_probability: availability_in_estrogen;
        extra_text_industry: extra_text_industry_combo;
        cargo_subtype_display: cargo_subtype_display_industry;
    }
}
// --------------------------------

// Pharmacy (Testosterone)
// ----------------------------------------------------------------
// CLASS: SECONDARY
// MULTIPLIERS: PRODUCTION_LEVEL, CONVERSION RATIO
// ACCEPTS: VIAL, VGOL, RWTS
// PRODUCES: 4 TEST                                     ($1520/cycle)
// CONVERTS: 16 (VIAL + VGOL + RWTS) -> {2, 4, 8} TEST  ({$47.50, $95, $190}/unit of input)

produce(produce_accept_pharmacy_t,
    [VIAL: LOAD_TEMP(0); VGOL: LOAD_TEMP(1); RWTS: LOAD_TEMP(2);],
    [TEST: LOAD_TEMP(4) * LOAD_PERM(91) * 2 / 16;]
)

switch(FEAT_INDUSTRIES, SELF, produce_cargo_arrival_pharmacy_t, [
    STORE_TEMP(incoming_cargo_waiting("VIAL"), 0),
    STORE_TEMP(incoming_cargo_waiting("VGOL"), 1),
    STORE_TEMP(incoming_cargo_waiting("RWES"), 2),
    STORE_TEMP(do_cargo_accept_cycle(incoming_cargo_waiting("VIAL"), incoming_cargo_waiting("VGOL"), incoming_cargo_waiting("RWTS")), 4),
]) {
    produce_accept_pharmacy_t;
}

produce(produce_regular_pharmacy_t, 
    [], 
    [TEST: LOAD_TEMP(4);],
    0
)

switch(FEAT_INDUSTRIES, SELF, produce_256_ticks_pharmacy_t, [
    production_cycle_tick(),
    STORE_TEMP(apply_production_modifiers(4, 1), 6)
]) {
    produce_regular_pharmacy_t;
}

item (FEAT_INDUSTRIES, industry_pharmacy_t) {
    property {
        substitute: 0x0E;
        name: string(STR_INDUSTRY_NAME_PHARMACY_T);
        nearby_station_name: string(STR_INDUSTRY_STATION_PHARMACY_T);
        life_type: IND_LIFE_TYPE_PROCESSING;
        cargo_types: [
            accept_cargo("VIAL"),
            accept_cargo("VGOL"),
            accept_cargo("RWTS"),
            produce_cargo("TEST", 0)
        ];
        spec_flags: bitmask(IND_FLAG_BUILT_NEAR_TOWN);
        new_ind_msg: string(STR_INDUSTRY_PLANTED_PHARMACY_T);
        closure_msg: string(STR_INDUSTRY_CLOSURE_PHARMACY_T);
        prob_in_game: 6;
        prob_map_gen: 9;
        fund_cost_multiplier: 100;
        map_colour: 101;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_pharmacy];
    }
    graphics {
        location_check: is_isolated(16);
        build_prod_change: initialize_industry;
        monthly_prod_change: check_seasonal_prod_update(string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACY_T_A), string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACY_T_B), string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACY_T_C), string(STR_INDUSTRY_PRODUCTION_INCREASE_PHARMACY_T_D), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACY_T_A), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACY_T_B), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACY_T_C), string(STR_INDUSTRY_PRODUCTION_DECREASE_PHARMACY_T_D), transported_last_month_pct("TEST"));
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        produce_256_ticks: produce_256_ticks_pharmacy_t;
        produce_cargo_arrival: produce_cargo_arrival_pharmacy_t;
        construction_probability: availability_in_testosterone;
        extra_text_industry: extra_text_industry_combo;
        cargo_subtype_display: cargo_subtype_display_industry;
    }
}
// --------------------------------

// Gender Clinic (Estrogen)
// ----------------------------------------------------------------
// CLASS: TERTIARY
// MULTIPLIERS:
// ACCEPTS: ESTR
// PRODUCES:
// CONVERTS:

produce(produce_accept_gender_clinic_e,
    [ESTR: incoming_cargo_waiting("ESTR");],
    []
)

item (FEAT_INDUSTRIES, industry_gender_clinic_e) {
    property {
        substitute: 0x0F;
        name: string(STR_INDUSTRY_NAME_GENDER_CLINIC_E);
        nearby_station_name: string(STR_INDUSTRY_STATION_GENDER_CLINIC_E);
        life_type: IND_LIFE_TYPE_BLACK_HOLE;
        cargo_types: [
            accept_cargo("ESTR"),
        ];
        spec_flags: bitmask(IND_FLAG_ONLY_IN_TOWNS);
        new_ind_msg: string(STR_INDUSTRY_PLANTED_GENDER_CLINIC_E);
        closure_msg: string(STR_INDUSTRY_CLOSURE_GENDER_CLINIC_E);
        prob_in_game: 4;
        prob_map_gen: 5;
        fund_cost_multiplier: 25;
        map_colour: 49;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_gender_clinic];
    }
    graphics {
        location_check: is_isolated(16);
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        build_prod_change: initialize_industry;
        produce_cargo_arrival: produce_accept_gender_clinic_e;
        construction_probability: availability_in_estrogen;
        cargo_subtype_display: cargo_subtype_display_industry;
    }
}
// --------------------------------

// Gender Clinic (Testosterone)
// ----------------------------------------------------------------
// CLASS: TERTIARY
// MULTIPLIERS:
// ACCEPTS: TEST
// PRODUCES:
// CONVERTS:

produce(produce_accept_gender_clinic_t,
    [TEST: incoming_cargo_waiting("TEST");],
    []
)

item (FEAT_INDUSTRIES, industry_gender_clinic_t) {
    property {
        substitute: 0x10;
        name: string(STR_INDUSTRY_NAME_GENDER_CLINIC_T);
        nearby_station_name: string(STR_INDUSTRY_STATION_GENDER_CLINIC_T);
        life_type: IND_LIFE_TYPE_BLACK_HOLE;
        cargo_types: [
            accept_cargo("TEST"),
        ];
        spec_flags: bitmask(IND_FLAG_ONLY_IN_TOWNS);
        new_ind_msg: string(STR_INDUSTRY_PLANTED_GENDER_CLINIC_T);
        closure_msg: string(STR_INDUSTRY_CLOSURE_GENDER_CLINIC_T);
        prob_in_game: 4;
        prob_map_gen: 5;
        fund_cost_multiplier: 25;
        map_colour: 48;
        min_cargo_distr: 1;
        conflicting_ind_types: [];
        layouts: [layout_gender_clinic];
    }
    graphics {
        location_check: is_isolated(16);
        random_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        monthly_prod_change: CB_RESULT_IND_PROD_NO_CHANGE;
        build_prod_change: initialize_industry;
        produce_cargo_arrival: produce_accept_gender_clinic_t;
        construction_probability: availability_in_testosterone;
        cargo_subtype_display: cargo_subtype_display_industry;
    }
}
// --------------------------------


// ----------------------------------------------------------------
// What a mess. Truly sorry you had to see this.
// ----------------------------------------------------------------